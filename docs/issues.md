# Issues（未完了）

このファイルは、REBORN Inventoryプロジェクトの**未完了Issue**を管理します。

**運用ルール：**
- 新しいIssueは該当カテゴリの最上部に追加
- 完了したIssue（✅ DONE）は `issues-closed.md` に移動
- 定期的にレビュー（週1回推奨）

**関連ドキュメント：**
- [TDD_POLICY.md](./TDD_POLICY.md) - Issue管理ルール詳細
- [ISSUE_TEMPLATE.md](./ISSUE_TEMPLATE.md) - Issue起票テンプレート
- [issues-closed.md](./issues-closed.md) - 完了Issueアーカイブ

---

## 🐛 バグ修正（Bug Fixes）

**現在のバグ: 2件**

---

## NOTIF-003 | バグ修正: FCMトークン自動更新未対応による通知未達

### 📌 基本情報
- [ ] カテゴリ: バグ修正
- [ ] 優先度: 高
- [ ] 影響範囲: FCM通知システム（PWA全体）
- [ ] 発見日: 2025-10-27

### 🐛 問題内容

FCMトークンの自動更新（refresh）がハンドリングされていないため、トークンが無効化されても古いトークンが「アクティブ」のまま残り、通知が届かなくなる。

**症状:**
- 一度は通知が届くが、しばらくすると届かなくなる
- アプリ削除→再インストール→FCM再設定で一時的に解決
- 同じ問題が繰り返し発生

**再現手順:**
1. PWAをインストール、FCM通知を設定
2. 商品登録 → 通知が届く（正常）
3. 時間経過後、またはブラウザキャッシュクリア後
4. 商品登録 → 通知が届かない（バグ）

### ✅ 期待動作

- FCMトークンが自動更新された際、新しいトークンをGASに自動送信
- 古いトークンを自動的に非アクティブ化
- 送信失敗時（トークン無効）に自動的にトークンを非アクティブ化
- ユーザーの手動操作なしで継続的に通知が届く

### 📍 関連ファイル
- `docs/index.html` - FCMトークン取得・登録処理（修正必要）
- `web_push.js` - 通知送信・エラーハンドリング（修正必要）

### 🔍 根本原因

#### 1. トークンリフレッシュイベント未実装
- `index.html` でトークン取得は実装済み
- トークンの自動更新（refresh）イベントのリスニングが未実装
- FCMトークンは以下の場合に自動更新される：
  - アプリの更新時
  - 長期間経過時（トークンの有効期限）
  - ブラウザのキャッシュクリア時

#### 2. 送信失敗時の自動無効化未実装
- `web_push.js` の `sendFCMToTokenV1` で送信失敗を検知
- エラー時にトークンを自動的に「非アクティブ」に変更していない
- 無効なトークンが「アクティブ」のまま残る

### 💡 修正案

#### 修正1: トークンリフレッシュイベントのハンドリング（index.html）
```javascript
// Firebase Messaging v10.7.1 の onTokenRefresh は非推奨
// 代わりに getToken() を定期的に呼び出してトークンの変更を検知

// 方法A: getToken() を定期的に実行（推奨）
setInterval(async () => {
  const newToken = await getToken(messaging, { vapidKey: VAPID_KEY });
  if (newToken !== currentToken) {
    console.log('FCMトークンが更新されました:', newToken);
    // GASに新トークンを送信
    await fetch(GAS_API_URL + '?action=subscribeFCM&token=' + newToken + '&userId=' + userEmail);
    currentToken = newToken;
  }
}, 60 * 60 * 1000); // 1時間ごとにチェック

// 方法B: PWA起動時に毎回トークンを確認・更新（より確実）
window.addEventListener('load', async () => {
  const token = await getToken(messaging, { vapidKey: VAPID_KEY });
  // 常に最新トークンをGASに送信（既存の場合は更新、新規の場合は追加）
  await fetch(GAS_API_URL + '?action=subscribeFCM&token=' + token + '&userId=' + userEmail);
});
```

#### 修正2: 送信失敗時の自動無効化（web_push.js）
```javascript
// sendFCMToTokenV1 関数の修正
if (responseCode === 200) {
  return { success: true, response: responseText };
} else if (responseCode === 404 || responseText.includes('not-found') || responseText.includes('unregistered')) {
  // トークンが無効な場合、自動的に非アクティブ化
  Logger.log('無効なトークンを検出、非アクティブ化します: ' + token);
  deactivateFCMToken(token);
  return { success: false, error: 'HTTP ' + responseCode + ': Token invalid (deactivated)' };
} else {
  return { success: false, error: 'HTTP ' + responseCode + ': ' + responseText };
}

// 新規関数: トークンを非アクティブ化
function deactivateFCMToken(token) {
  try {
    const ss = SpreadsheetApp.getActiveSpreadsheet();
    const sheet = ss.getSheetByName(FCM_TOKENS_SHEET);
    if (!sheet) return;

    const data = sheet.getDataRange().getValues();
    for (let i = 1; i < data.length; i++) {
      const rowToken = data[i][2]; // 列C: FCMトークン
      if (rowToken === token) {
        sheet.getRange(i + 1, 5).setValue('非アクティブ'); // 列E: ステータス
        Logger.log('トークンを非アクティブ化しました: 行' + (i + 1));
        break;
      }
    }
  } catch (error) {
    Logger.log('deactivateFCMToken error: ' + error);
  }
}
```

### ✏️ 修正内容

#### Phase 1: 無効トークン自動無効化 ✅ 完了
- [x] web_push.js に deactivateFCMToken 関数を追加
- [x] sendFCMToTokenV1 でエラー時に自動無効化を実行
  - 404, NOT_FOUND, UNREGISTERED, INVALID_ARGUMENT を検知
  - 該当トークンを「非アクティブ」に自動変更
- [x] デプロイ（GAS @341 + PWA）

#### Phase 2: トークンリフレッシュ処理 ⏳ 保留中（INV-004完了後）
- [ ] index.html にトークンリフレッシュ処理を追加（方法B: 起動時チェック採用）
- [ ] テスト実行（TC-NOTIF-003-001）
- [ ] デプロイ（PWA）

### 🧪 テストケース

#### TC-NOTIF-003-001: トークン更新の自動検知
**前提条件:**
- PWAがインストール済み
- FCM通知が設定済み

**実行操作:**
1. PWAを開く
2. ブラウザのDevToolsでコンソールを確認
3. `localStorage.clear()` を実行（トークンクリア）
4. ページをリロード

**期待結果:**
- 新しいトークンが自動取得される
- GASに新トークンが送信される
- スプレッドシートに新トークンが「アクティブ」で登録される
- 商品登録で通知が届く

#### TC-NOTIF-003-002: 無効トークンの自動無効化
**前提条件:**
- FCM通知登録シートに無効なトークンが「アクティブ」で存在

**実行操作:**
1. 商品登録を実行（通知送信）
2. 無効なトークンへの送信が失敗
3. スプレッドシートの「FCM通知登録」シートを確認

**期待結果:**
- 送信失敗したトークンが自動的に「非アクティブ」に変更される
- 通知ログに「Token invalid (deactivated)」が記録される

### 📝 テスト結果
- [ ] TC-NOTIF-003-001: PASS / FAIL
- [ ] TC-NOTIF-003-002: PASS / FAIL
- [ ] デグレード確認: OK / NG

### 状態
- [ ] ✅ DONE (完了日: )

---

## 🔧 パフォーマンス改善（Performance）

**現在のパフォーマンス課題: 0件**
**完了済み: 2件（PERF-001, PERF-002）**

---

## PERF-002 | パフォーマンス: PWA初期起動が遅い（白い画面→商品登録まで待ち時間）

### 📌 基本情報
- [ ] カテゴリ: パフォーマンス改善
- [ ] 優先度: 中
- [ ] 影響範囲: PWA初期起動
- [ ] 発見日: 2025-10-28

### 🐛 問題内容
PWAをリロードして開く際、以下の流れで待ち時間が発生し体感速度が遅い：
1. アプリアイコンをタップ
2. 白い画面が表示される（待ち時間）
3. 商品登録画面が表示される
4. 設定している管理番号が読み込まれる

**ユーザーフィードバック:**
> "アプリをリロードして開くときに少し待ち時間があるのが気になってます"

### ✅ 期待動作
- 白い画面の表示時間を最小化
- 体感速度の向上（スケルトンUI表示）
- 2回目以降の起動を高速化（キャッシュ活用）

### 📍 関連ファイル
- `docs/index.html` (PWAメインファイル、初期化処理)
- `docs/firebase-messaging-sw.js` (Service Worker、キャッシュ戦略)

### 🔍 原因分析
1. **`window.addEventListener('load')`使用** (index.html:619)
   - 全リソース（画像、iframe含む）の読み込み完了まで待つため遅い

2. **Service Workerでリソースキャッシュ未実装**
   - fetchイベントハンドラがない
   - 2回目以降も毎回サーバーから取得

3. **GASドメインへのプリコネクト未実装**
   - DNS解決・TCP接続・TLS接続が起動時に発生

4. **スケルトンUI未実装**
   - 白い画面で待たされる体感速度が遅い

### 💡 改善案

#### 優先度高（即効性あり）
1. **'load' → 'DOMContentLoaded'に変更**
   - 期待効果: 0.5〜1秒短縮

2. **プリコネクト追加**
   - `dns-prefetch`, `preconnect` をGASドメインに追加
   - 期待効果: 0.2〜0.5秒短縮

3. **スケルトンUI追加**
   - ローディング中に構造を表示
   - 期待効果: 体感速度向上

#### 優先度中（2回目以降に効果）
4. **Service Workerでキャッシュ実装**
   - fetchイベントでCache APIを実装
   - 期待効果: 2回目以降0.5〜2秒短縮

5. **index.htmlの事前キャッシュ**
   - installイベントで主要リソースをキャッシュ
   - 期待効果: オフライン対応も可能に

### ✏️ 実装内容
- [x] DOMContentLoadedへ変更 (index.html:705)
- [x] プリコネクト追加 (index.html:19-23)
- [x] スケルトンUI実装 (index.html:450-516, 623-633)
- [x] Service Workerにfetchイベント実装 (firebase-messaging-sw.js:173-217)
- [x] 主要リソースの事前キャッシュ実装 (firebase-messaging-sw.js:12-19, 132-151)
- [x] **iframe遅延ロード実装** (index.html:637-638, 745-754) - 追加改善
- [x] デプロイ実行（Cloudflare Pages）- コミット 91a0842, 5d15e09
- [ ] 動作テスト実施（ユーザーによる体感速度確認待ち）

**実装詳細:**

#### 1. DOMContentLoadedへ変更（index.html:705）
```javascript
// 変更前: window.addEventListener('load', ...)
// 変更後: document.addEventListener('DOMContentLoaded', ...)
```
- 全リソース読み込み待ちから、DOM構築完了時点に変更
- 期待効果: 0.5〜1秒短縮

#### 2. プリコネクト追加（index.html:19-23）
```html
<link rel="dns-prefetch" href="https://script.google.com">
<link rel="dns-prefetch" href="https://www.gstatic.com">
<link rel="preconnect" href="https://script.google.com" crossorigin>
<link rel="preconnect" href="https://www.gstatic.com" crossorigin>
```
- DNS解決・TCP接続・TLS接続を先行実行
- 期待効果: 0.2〜0.5秒短縮

#### 3. スケルトンUI実装（index.html:450-516, 623-633）
- パルスアニメーション付きプレースホルダー
- iframe読み込み完了時に自動非表示
- 期待効果: 体感速度の大幅向上（白い画面解消）

#### 4. Service Worker キャッシュ実装（firebase-messaging-sw.js）
**事前キャッシュ（installイベント）:**
- index.html, manifest.json, アイコン類を初回インストール時にキャッシュ

**Cache First戦略（fetchイベント）:**
- キャッシュ優先、なければネットワークから取得
- GASドメインは除外（常に最新版を取得）
- 期待効果: 2回目以降0.5〜2秒短縮

#### 5. iframe遅延ロード実装（index.html:637-638, 745-754）【追加改善】
```javascript
// HTML: src → data-src に変更
<iframe id="gas-iframe" data-src="https://..."></iframe>

// JavaScript: DOMContentLoaded後、100ms遅延してから読み込み
setTimeout(() => {
  iframe.src = iframe.getAttribute('data-src');
}, 100);
```
- **ユーザーフィードバック受けて追加実装**
- HTML読み込み時にiframeを即座に読み込まない
- DOMContentLoaded完了後、100ms待ってからiframe読み込み開始
- 期待効果: **初期表示0.3〜0.7秒短縮、体感速度さらに向上**

### 📝 測定結果
- [x] 改善前: 白い画面が長く表示され、待ち時間にストレスを感じる状態
- [x] 改善後: スケルトンUIが表示され、体感速度が向上
- [x] **ユーザー評価**: 「前よりはストレスは感じなくなりました」

**実施した改善施策（計6項目）:**
1. ✅ DOMContentLoadedへ変更（0.5〜1秒短縮）
2. ✅ プリコネクト追加（0.2〜0.5秒短縮）
3. ✅ スケルトンUI実装（体感速度向上）
4. ✅ Service Workerキャッシュ（2回目以降0.5〜2秒短縮）
5. ✅ 事前キャッシュ実装（オフライン対応）
6. ✅ iframe遅延ロード（0.3〜0.7秒短縮）

**総合評価:**
- 劇的な改善ではないが、一定のストレス軽減効果を達成
- 白い画面がスケルトンUIに置き換わり、体感速度が向上
- GAS Web App自体の初期化時間は避けられない制約

**今後の改善余地:**
- さらなる高速化にはGAS側の最適化やアーキテクチャ変更が必要
- 現時点でフロントエンド側の最適化は十分実施済み

### 状態
- [x] ✅ DONE (完了日: 2025-10-28)

---

## PERF-001 | パフォーマンス: PWA画面遷移が遅い（特に在庫管理が5秒）

### 📌 基本情報
- [ ] カテゴリ: パフォーマンス改善
- [ ] 優先度: 中
- [ ] 影響範囲: PWA全体（特に在庫管理）
- [ ] 発見日: 2025-10-24

### 🐛 問題内容
PWA版で画面遷移（商品登録、設定、在庫管理）が遅く、体感で鈍い。
特に在庫管理は5秒程度かかり、ロードマークが表示される。

**症状:**
- 商品登録 → 設定 → 在庫管理の遷移に時間がかかる
- 在庫管理は特に遅く、約5秒
- 中央にロードマークが表示される

### ✅ 期待動作
- 画面遷移が1秒以内（目標）
- 最低でも2秒以内に表示開始
- ローディング中も操作可能な状態を維持

### 📍 関連ファイル
- `docs/index.html` (iframe制御、navigateToPage関数)
- `menu.js` (doGet関数、Web App初期化)
- `sidebar_inventory.html` (在庫管理UI、初期化処理)
- `inventory.js` (searchInventoryAPI, getStatisticsAPI)

### 🔍 調査項目
- [ ] iframe読み込み時間を計測
- [ ] GAS Web App初期化時間を計測
- [ ] sidebar_inventory.html初期化時のAPI呼び出しを確認
- [ ] スプレッドシートアクセス時間を計測
- [ ] ブラウザDevToolsでネットワーク/パフォーマンス分析

### 💡 改善案
1. **ローディングUI改善**
   - プログレスバー追加
   - スケルトンUI表示
   - 「読み込み中...」メッセージ

2. **API最適化**
   - 初期表示時は最低限のデータのみ取得
   - 統計情報は遅延ロード
   - ページネーションのデフォルト件数削減（50→20）

3. **キャッシュ活用**
   - 前回の統計情報をlocalStorageにキャッシュ
   - マスタデータ（ブランド、カテゴリ等）をキャッシュ

4. **iframe事前ロード**
   - 非表示iframeで事前にロード
   - 表示時は切り替えのみ

5. **遅延ロード**
   - 画像は遅延ロード
   - 商品一覧は初回10件のみ表示

### ✏️ 実装内容
- [x] パフォーマンス計測（各処理の時間）
- [x] ボトルネック特定（原因: loadDashboard()とsearch()を同時実行）
- [x] Phase 1: ページネーション最適化（50→10件）
- [x] Phase 2: API統合実装（getInventoryDashboardAPI作成）
- [x] sidebar_inventory.htmlの修正（loadDashboardAndSearch()に統合）
- [x] デプロイ完了（GAS）
- [ ] Phase 3: キャッシュ実装（localStorage活用）- 次回実施予定
- [ ] ユーザーテスト実施
- [ ] 改善効果の実測

### 📝 測定結果
- [x] 改善前: 在庫管理ロード時間 約5秒（ユーザー報告）
- [x] Phase 2後: 在庫管理ロード時間 **3.6〜4.8秒**（実測 2025-10-26）
- [x] 改善率: **約28%削減**（期待より低い）
- [x] Phase 3調査: **8-9秒**（70商品、ユーザー報告 2025-10-28）
  - getStatisticsAPI: **5.1秒** ← ボトルネック特定！
  - 11回のシート読み込みが原因

**実測データ（コンソールログ）:**
- API応答時間1: 3597ms（約3.6秒）
- API応答時間2: 4803ms（約4.8秒）
- **体感的にも遅さを感じる** → Phase 3で改善必須

### 💡 実装した改善内容
**Phase 1: ページネーション最適化**
- デフォルト表示件数: 50件 → 10件に変更
- sidebar_inventory.html: 248行目

**Phase 2: API統合**
- 新規API作成: `getInventoryDashboardAPI(params)` (inventory.js: 817-1122行目)
- 1回のスプレッドシートスキャンで統計と商品一覧の両方を取得
- 既存の`loadDashboard()`と`search()`を`loadDashboardAndSearch()`に統合
- スプレッドシートアクセスを2回→1回に削減

**期待効果 vs 実測:**
- 期待: 約80%削減（5秒→1秒）
- 実測: 約28%削減（5秒→3.6〜4.8秒）
- **ギャップ原因**: 統計計算で全件スキャンが発生している可能性

### 🔧 Phase 3: 統計API最適化 ✅

**2025-10-28 実装完了:**

**実装内容:**
1. **統計API最適化** (inventory.js:1281-1321)
   - 根本原因特定: `getStatisticsAPI()`が`getStatsValue()`を11回呼び出し、毎回シート全体読み込み
   - 修正内容: `getAllStatsValues()`を1回だけ呼び出して辞書化、11回のシート読み込みを1回に削減
   - 実測結果: **8-9秒 → 6-7秒** (約20%削減)

---

### 🔧 Phase 4: インデックスベース2段階ロード ✅

**2025-10-28 実装完了:**

**実装内容:**
1. **getInventoryDashboardAPI の最適化** (inventory.js:1377-1707)
   - 軽量インデックス（15列のみ）で全件フィルタリング
   - マッチした商品の詳細データを個別に読み込み（10件のみ）
   - 大量フィルタリング＋少量詳細取得の分離戦略

**実測結果:**
- ロード時間: **6-7秒 → 2.4秒** (約73%削減)
- 内訳: フィルタリング 1200ms、詳細取得 1164ms

---

### 🔧 Phase 5: 全列インデックス化 ✅

**2025-10-28 実装完了:**

**実装内容:**
1. **INDEX_COLUMNS の拡張** (inventory.js:1377-1407)
   - 15列 → 26列（全必要データを含む）
   - 詳細データの個別読み込みを完全に廃止
   - インデックスに全データを含めることで1段階ロードを実現

2. **products配列の直接生成** (inventory.js:1653-1706)
   - インデックスから直接productsを生成
   - 1164msかかっていた詳細データ読み込みステップを削除

**実測結果:**
- ロード時間: **2.4秒 → 1.4秒** (約84%削減)
- 詳細取得1164msを完全に削減

---

### 🔧 Phase 6: 統計キャッシュ実装 ✅

**2025-10-28 実装完了:**

**実装内容:**
1. **PropertiesService による統計キャッシュ** (inventory.js:110-172)
   - 統計シートのセルD1にタイムスタンプを記録
   - PropertiesService でキャッシュを保存
   - タイムスタンプ一致時はキャッシュから取得（384ms → 152ms）

2. **自動キャッシュ無効化** (inventory.js:178-201)
   - setStatsValue() 実行時にD1タイムスタンプを更新
   - 統計更新時に自動的にキャッシュ無効化

3. **D1自動初期化の実装**
   - D1が空の場合は自動的に現在時刻を書き込み
   - 初回実行時のキャッシュエラーを防止

**実測結果:**
- ロード時間: **1.4秒 → 0.991秒** (約89%削減、**目標1秒達成！**)
- 統計取得: 384ms → 152ms (キャッシュヒット時)

---

### 🎨 UX改善: 初期表示の最適化 ✅

**2025-10-28 実装完了:**

**ユーザーフィードバック:**
> "検索で表示させられれば、ここに全てを表示させる必要がない"

**実装内容:**
1. **loadDashboard() の変更** (sidebar_inventory.html:464-501)
   - 初期表示は統計のみを表示
   - 商品一覧は検索ボタンクリック時のみ表示
   - DOM要素の存在チェックを追加（無限ローディング防止）

**実測結果:**
- 初期表示: **0.474秒** (95%削減、統計のみ)
- 検索実行: **0.991秒** (89%削減、統計+商品一覧)

---

### 📊 最終パフォーマンス結果

| Phase | 実装内容 | ロード時間 | 改善率 |
|-------|---------|-----------|--------|
| 初期状態 | オリジナル実装 | 8-9秒 | - |
| Phase 1-2 | API統合、ページネーション | 5秒 | 44% |
| Phase 3 | 統計API最適化 | 6-7秒 | 20% |
| Phase 4 | インデックス2段階ロード | 2.4秒 | 73% |
| Phase 5 | 全列インデックス化 | 1.4秒 | 84% |
| Phase 6 | 統計キャッシュ | **0.991秒** | **89%** |
| UX改善 | 初期表示=統計のみ | **0.474秒** | **95%** |

**目標達成:**
- ✅ 1秒以内目標: 達成（0.991秒 / 0.474秒）
- ✅ ユーザー体感: 大幅に改善
- ✅ 将来拡張性: 1,000商品規模でも対応可能な設計

---

### 🔑 重要な教訓

1. **デプロイID管理の徹底**
   - PWA版（docs/index.html）のデプロイIDが古いままになる問題が2回発生
   - MANDATORY_SESSION_START_CHECKLIST.md にデプロイID確認を追加

2. **キャッシュの初期化が重要**
   - 統計シートD1が空でキャッシュが動作しない問題
   - 自動初期化ロジックで解決

3. **DOM要素の存在チェック**
   - 初期表示最適化で無限ローディング発生
   - DOM要素のnullチェックで解決

---

### 状態
- [x] ✅ DONE (完了日: 2025-10-28)

---

## ✨ 機能追加・改善（Features & Improvements）

**現在の機能追加・改善: 6件**

---

## INV-003 | 機能追加: 複数プラットフォーム対応設計・実装

### 📌 基本情報
- [ ] カテゴリ: 機能追加（戦略的拡張）
- [ ] 優先度: 最高（事業成長の要）
- [ ] 影響範囲: データ構造全体、在庫管理、API連携
- [ ] 要望日: 2025-10-27

### 💡 要望内容

8つの販売プラットフォームに対応し、複数プラットフォームでの同時出品・在庫管理を可能にする。

**背景:**
- メルカリ単独依存のリスク（規制強化、アカウント制限）
- チーム運用の困難さ（通常メルカリのアカウント制限）
- SaaS化への展開（複数顧客×複数プラットフォーム）
- 販路拡大による事業成長

**対象プラットフォーム:**
- Phase 1: メルカリ（手動）← 現在
- Phase 2: メルカリShops（優先、API連携）
- Phase 3: ラクマ、Yahoo!フリマ、BASE、Shopify
- Phase 4: Yahoo!オークション、eBay

### ✅ 期待動作

**1商品×複数プラットフォーム出品:**
- AA-1001をメルカリ、メルカリShops、BASEに同時出品可能
- プラットフォームごとに異なる価格設定可能（手数料率が異なるため）
- プラットフォームごとの出品ステータス管理

**在庫同期:**
- 1つのプラットフォームで販売された時、他のプラットフォームの在庫を自動更新
- 例：メルカリで販売 → 全プラットフォームで「販売済み」または「取り下げ」

**プラットフォーム別情報管理:**
- プラットフォーム商品ID（merc_xxx、shops_yyy等）
- 出品日時、販売日時
- プラットフォーム別利益計算

### 📍 関連ファイル・ドキュメント
- `docs/MULTI_PLATFORM_DESIGN.md` - 設計ドキュメント（詳細設計）
- スプレッドシート - プラットフォーム出品管理シート（新規作成予定）
- `inventory.js` - API拡張
- `sidebar_inventory.html` - UI拡張

### 🏗️ 実装内容（Phase別）

#### Phase 2-1: データ構造拡張 ⏳ 未着手
- [ ] プラットフォーム出品管理シート作成
  - 列定義：管理番号、プラットフォーム、出品ステータス、商品ID、出品価格、出品日時、販売日時、手数料率、利益、備考
  - テストデータ投入
- [ ] 商品マスタシートに全体ステータス列追加
  - 登録済み、出品可能、一部出品中、全出品中、一部販売済み、全販売済み、取り下げ
- [ ] マイグレーションスクリプト作成
  - 既存データをプラットフォーム出品管理シートに移行
  - メルカリ出品データの移行

#### Phase 2-2: バックエンドAPI拡張 ⏳ 未着手
- [ ] `getPlatformListingsAPI(managementNumber)` - 特定商品のプラットフォーム別出品状態取得
- [ ] `createPlatformListingAPI(params)` - プラットフォームへの出品情報登録
- [ ] `updatePlatformListingAPI(params)` - プラットフォーム出品情報更新
- [ ] `deletePlatformListingAPI(params)` - プラットフォーム出品取り下げ
- [ ] `syncInventoryAPI(managementNumber)` - 在庫同期処理

#### Phase 2-3: UI拡張（在庫管理画面） ⏳ 未着手
- [ ] 商品カードにプラットフォーム別ステータス表示
  - 例：[メ] 出品中 ¥5,000 / [Sh] 準備中 ¥5,200 / [+] 出品可能
- [ ] 商品詳細モーダルにプラットフォーム管理セクション追加
  - プラットフォーム別：ステータス、商品ID、価格、出品日、[出品する][取り下げ][編集]ボタン
- [ ] プラットフォーム追加UI
  - 出品可能なプラットフォーム一覧から選択
  - 出品価格の自動計算（手数料率考慮）

#### Phase 3-1: メルカリShops API連携 ⏳ 未着手（ショップ開設待ち）
- [ ] メルカリShops API調査
  - APIドキュメント確認
  - 認証方式（OAuth等）
  - 商品登録、在庫管理、注文取得等のエンドポイント確認
- [ ] OAuth認証実装
- [ ] 商品登録API連携
  - 商品情報送信
  - 画像URL送信（R2から）
  - 商品ID取得
- [ ] 在庫同期実装
  - Webhook受信（販売通知）
  - またはポーリング（定期的に注文状態確認）
- [ ] テスト運用

#### Phase 3-2: その他プラットフォームAPI調査 ⏳ 未着手
- [ ] BASE API調査・ドキュメント確認
- [ ] Shopify API調査・ドキュメント確認
- [ ] ラクマ API調査（API提供有無確認）
- [ ] Yahoo!フリマ API調査（API提供有無確認）
- [ ] Yahoo!オークション API調査
- [ ] eBay API調査

### 🧪 テストケース

#### TC-INV-003-001: プラットフォーム出品管理シート作成
**前提条件:**
- 既存の商品マスタに商品が登録されている（例：AA-1001）

**実行操作:**
1. プラットフォーム出品管理シートを作成
2. AA-1001のメルカリ出品情報を登録
3. AA-1001のメルカリShops出品準備情報を登録

**期待結果:**
- プラットフォーム出品管理シートに2行追加される
- 管理番号、プラットフォーム、ステータス等が正しく記録される

#### TC-INV-003-002: 在庫管理画面でプラットフォーム別表示
**前提条件:**
- AA-1001がメルカリ（出品中）、メルカリShops（出品準備中）に登録されている

**実行操作:**
1. 在庫管理画面を開く
2. AA-1001の商品カードを確認

**期待結果:**
- 商品カードに「[メ] 出品中 ¥5,000」「[Sh] 準備中 ¥5,200」が表示される

#### TC-INV-003-003: プラットフォームへの出品登録
**前提条件:**
- AA-1001が商品マスタに登録済み
- メルカリShopsに未出品

**実行操作:**
1. 商品詳細モーダルを開く
2. 「メルカリShopsに出品する」ボタンをクリック
3. 出品価格を入力（¥5,200）
4. 出品実行

**期待結果:**
- プラットフォーム出品管理シートに新規行追加
- ステータス：出品準備中
- （API連携後）メルカリShopsに商品が登録される

### 📝 テスト結果
- [ ] TC-INV-003-001: PASS / FAIL
- [ ] TC-INV-003-002: PASS / FAIL
- [ ] TC-INV-003-003: PASS / FAIL
- [ ] デグレード確認（既存機能）: OK / NG

### 状態
- [ ] ✅ DONE (完了日: )

### 📌 備考
- 設計ドキュメント: `docs/MULTI_PLATFORM_DESIGN.md`参照
- Phase 2開始タイミング: メルカリ手動運用完成後
- メルカリShops: ショップ開設完了後にPhase 3開始

---

## INV-004 | 機能追加: 販売記録機能 + マスタ管理UI

### 📌 基本情報
- [ ] カテゴリ: 機能追加
- [ ] 優先度: 高
- [ ] 影響範囲: 在庫管理、販売記録、マスタデータ管理
- [ ] 要望日: 2025-10-27

### 💡 要望内容

販売記録機能とマスタデータ管理UIを実装し、SaaS化を見据えたユーザーフレンドリーなマスタ管理を実現する。

**背景:**
- メルカリ等での販売時に必要な情報（発送方法、送料、梱包資材等）を記録
- 利益計算の自動化
- マスタデータ（発送方法、梱包資材）をシート直接編集ではなくUI経由で管理
- SaaS化を見据え、商品登録と同様に設定画面で完結する設計

**主要機能:**
1. 販売記録モーダル（商品カードから起動）
2. 発送方法マスタ管理UI
3. 梱包資材マスタ管理UI

### ✅ 期待動作

**1. 販売記録モーダル:**
- 商品カードの「販売記録」ボタンから起動
- 販売日、販売先、販売金額、発送方法、梱包資材を入力
- 利益計算の自動表示（販売金額 - 仕入金額 - 手数料 - 送料 - 梱包資材費）
- プラットフォーム別手数料率の自動計算（メルカリ10%等）
- 保存時に商品ステータスを「販売済み」に自動更新

**2. 発送方法マスタ管理UI:**
- メニュー: マスタ・設定 → 🚚 発送方法マスタ管理
- テーブル形式で一覧表示（発送方法1、発送方法2、送料）
- 新規追加、編集、削除機能
- バリデーション（送料は数値のみ、必須項目チェック）

**3. 梱包資材マスタ管理UI:**
- メニュー: マスタ・設定 → 📦 梱包資材マスタ管理
- テーブル形式で一覧表示（商品名、略称、単価、在庫数等）
- 新規追加、編集、削除機能
- 単価の自動計算（価格 ÷ 個数）
- 在庫数の表示（入庫数 - 出庫数）

### 📍 関連ファイル
- `docs/SALES_RECORDING_DESIGN.md` - 設計ドキュメント
- `inventory.js` - バックエンドAPI
- `sidebar_inventory.html` - 販売記録モーダルUI
- `setup_sales_recording_sheets.js` - マスタシートセットアップ
- `shipping_method_master_manager.js` - 発送方法マスタ管理バックエンド（新規）
- `shipping_method_master_ui.html` - 発送方法マスタ管理UI（新規）
- `packaging_materials_manager.js` - 梱包資材マスタ管理バックエンド（新規）
- `packaging_materials_ui.html` - 梱包資材マスタ管理UI（新規）
- `menu.js` - メニュー項目追加

### 🧪 テストケース

#### TC-INV-004-001: 販売記録モーダルの表示
**前提条件:**
- 商品 AA-1001 が「出品中」
- 発送方法マスタにデータ登録済み
- 梱包資材マスタにデータ登録済み

**実行操作:**
1. 在庫管理画面で AA-1001 の「販売記録」ボタンをクリック

**期待結果:**
- 販売記録モーダルが表示される
- 販売日が今日の日付で初期化される
- 発送方法のプルダウンが正常に表示される
- 梱包資材のプルダウンが正常に表示される

#### TC-INV-004-002: 販売記録の保存と利益計算
**前提条件:**
- 商品 AA-1001 の仕入金額: ¥3,000、出品金額: ¥5,000

**実行操作:**
1. 販売記録モーダルを開く
2. 販売金額: ¥5,000
3. 販売先: メルカリ（手数料率10%）
4. 発送方法: らくらくメルカリ便 → ネコポス（¥210）
5. 梱包資材1: A4ジッパー袋（¥9.39）
6. 保存ボタンをクリック

**期待結果:**
- プラットフォーム手数料: ¥500（5,000 × 10%）
- 送料: ¥210
- 梱包資材費: ¥9.39
- 最終利益: ¥1,280.61（5,000 - 3,000 - 500 - 210 - 9.39）
- スプレッドシートに販売情報が記録される
- 商品ステータスが「販売済み」に変更される
- 梱包資材の出庫数が +1 される

#### TC-INV-004-003: 発送方法マスタ管理（新規追加）
**前提条件:**
- 発送方法マスタシートが存在

**実行操作:**
1. メニュー: マスタ・設定 → 🚚 発送方法マスタ管理
2. [+ 新規追加] ボタンをクリック
3. 発送方法1: 定形郵便
4. 発送方法2: 50g以内
5. 送料: 94
6. 保存ボタンをクリック

**期待結果:**
- 発送方法マスタシートに新規行追加
- 一覧に新しい発送方法が表示される
- 販売記録モーダルで新しい発送方法が選択可能

#### TC-INV-004-004: 梱包資材マスタ管理（編集）
**前提条件:**
- 梱包資材マスタに「A4ジッパー袋」が登録済み

**実行操作:**
1. メニュー: マスタ・設定 → 📦 梱包資材マスタ管理
2. 「A4ジッパー袋」の [編集] ボタンをクリック
3. 価格を 939 → 1000 に変更
4. 保存ボタンをクリック

**期待結果:**
- 梱包資材マスタシートの価格が更新される
- 単価（1個あたり）が自動再計算される（1000 ÷ 100 = 10.00）
- 一覧に反映される

#### TC-INV-004-005: 発送方法の連動プルダウン
**前提条件:**
- 販売記録モーダルが開いている

**実行操作:**
1. 発送方法（カテゴリ）で「らくらくメルカリ便」を選択

**期待結果:**
- 発送方法（詳細）のプルダウンが有効化される
- らくらくメルカリ便の詳細選択肢のみが表示される（ネコポス、宅急便60等）
- 金額は表示されない（例: 「ネコポス」のみ）

#### TC-INV-004-006: 梱包資材の動的追加
**前提条件:**
- 販売記録モーダルが開いている

**実行操作:**
1. 梱包資材1〜3が表示されている
2. [+ 梱包資材を追加] ボタンをクリック

**期待結果:**
- 梱包資材4が追加される
- プルダウンが正常に機能する
- 利益計算に反映される

### ✏️ 実装内容

#### Phase 1: 販売記録モーダルUI ✅ 完了
- [x] バックエンドAPI実装（inventory.js）
- [x] フロントエンド実装（sidebar_inventory.html）
- [x] マスタシートセットアップスクリプト（setup_sales_recording_sheets.js）
- [x] メニュー項目追加（menu.js）
- [x] デプロイ（GAS @323 + PWA）
- [x] UI改善（発送方法詳細の金額表示削除、梱包資材プルダウン非同期修正）

#### Phase 2: 発送方法マスタ管理UI ✅ 完了
- [x] バックエンドAPI実装（shipping_method_master_manager.js 新規作成）
  - [x] getShippingMethodsAPI() - 全発送方法取得
  - [x] addShippingMethodAPI(params) - 新規追加（重複チェック付き）
  - [x] updateShippingMethodAPI(params) - 編集
  - [x] deleteShippingMethodAPI(rowIndex) - 削除
- [x] フロントエンド実装（shipping_method_master_ui.html 新規作成）
  - [x] 一覧表示（テーブル形式）
  - [x] 新規追加モーダル
  - [x] 編集モーダル
  - [x] 削除確認ダイアログ
  - [x] バリデーション（必須入力、重複チェック）
- [x] メニュー項目追加（menu.js）
  - [x] 「🚚 発送方法マスタ管理」追加
- [ ] TC-INV-004-003 実行（テスト）- 次回実施

#### Phase 3: 梱包資材マスタ管理UI ✅ 完了
- [x] バックエンドAPI実装（packaging_materials_manager.js 新規作成）
  - [x] getPackagingMaterialsAPI() - 全データ取得
  - [x] addPackagingMaterialAPI(params) - 新規追加（重複チェック付き）
  - [x] updatePackagingMaterialAPI(params) - 編集
  - [x] deletePackagingMaterialAPI(rowIndex) - 削除
- [x] フロントエンド実装（packaging_materials_ui.html 新規作成）
  - [x] カード形式レイアウト（11項目対応）
  - [x] 編集可能フィールド: 商品名、略称、発注先、商品リンク、商品画像URL、個数、価格、入庫数
  - [x] 読み取り専用フィールド: 1個あたり（自動計算）、出庫数、在庫数（自動計算）
  - [x] 在庫数アラート（10個以下で警告表示）
  - [x] バリデーション（必須入力、重複チェック）
- [x] メニュー項目追加（menu.js）
  - [x] スプレッドシート: 「📦 梱包資材マスタ管理」追加
  - [x] PWA: アコーディオンメニューに追加
- [x] デプロイ（GAS @328 + PWA）
- [ ] TC-INV-004-004 実行（テスト）- 次回実施

#### Phase 4: 総合テスト ⏳ 未着手
- [ ] 全テストケース実行
- [ ] デグレード確認

### 📝 テスト結果
- [ ] TC-INV-004-001: PASS / FAIL
- [ ] TC-INV-004-002: PASS / FAIL
- [x] TC-INV-004-003: PASS（2025-10-28）- 新規追加、一覧表示、販売記録モーダル連携が正常動作
- [x] TC-INV-004-004: PASS（2025-10-28）- 編集、単価自動計算、一覧反映が正常動作
- [x] TC-INV-004-005: PASS（2025-10-28）- カテゴリ選択による詳細プルダウン連動が正常動作
- [x] TC-INV-004-006: PASS（2025-10-28）- UI上では動的追加が正常動作、ただしシートは3列まで（Issue: INV-004-COL）
- [ ] デグレード確認: OK / NG

### 🚀 デプロイ履歴
- 2025-10-27: Phase 1 デプロイ（GAS @323 + PWA）
  - 販売記録モーダル実装
  - マスタシートセットアップスクリプト追加
- 2025-10-27: UI改善デプロイ（GAS @323 + PWA）
  - 発送方法詳細の金額表示削除
  - 梱包資材プルダウン非同期読み込み修正
- 2025-10-27: Phase 2 デプロイ（GAS @325）
  - 発送方法マスタ管理UI実装

### 状態
- [x] ✅ DONE (完了日: 2025-10-28)

### 📌 備考
- Phase 1（販売記録モーダル）は実装完了、デプロイ済み
- Phase 2（発送方法マスタ管理UI）実装完了
- Phase 3（梱包資材マスタ管理UI）実装完了
- Phase 4（総合テスト）完了（TC-003〜006 全てPASS）
- 設計方針: 別々の専用UIで実装（案B採用）
- SaaS化を見据え、シート直接編集ではなくUI経由での管理を実現
- **改善Issue**: INV-004-UI（UI改善）、INV-004-LOT（FIFO）、INV-004-COL（列追加）を別途対応予定

---

## INV-004-UI | UI改善: 発送方法マスタ管理（プリセット選択式 + カテゴリ別表示）

### 📌 基本情報
- [ ] カテゴリ: UI改善
- [ ] 優先度: 中
- [ ] 影響範囲: 発送方法マスタ管理UI
- [ ] 要望日: 2025-10-28

### 💡 要望内容

発送方法マスタ管理UIの使い勝手を改善する。

**現在の問題点:**
1. **フリーテキスト入力**
   - 表記揺れが発生（「らくらくメルカリ便」「メルカリ便」等）
   - 発送方法はプラットフォームで決まっているのに独自入力が必要

2. **登録順に表示**
   - カテゴリ（らくらくメルカリ便、ゆうゆうメルカリ便等）がバラバラ
   - 管理・把握が困難

**改善方針:**
- フリーテキスト入力 → プリセット選択式
- 登録順表示 → カテゴリ別アコーディオン表示

### ✅ 期待動作

#### 新規追加UI（プリセット選択式）
```
┌─────────────────────────────────────┐
│ 📦 新規発送方法追加                  │
├─────────────────────────────────────┤
│ カテゴリ（発送方法1）:               │
│ ┌─────────────────────────────┐     │
│ │ らくらくメルカリ便          ▼│     │  ← プルダウン選択
│ └─────────────────────────────┘     │
│                                     │
│ 詳細（発送方法2）:                   │
│ ┌─────────────────────────────┐     │
│ │ ネコポス                    ▼│     │  ← カテゴリに応じた選択肢
│ └─────────────────────────────┘     │
│                                     │
│ 送料（円）:                          │
│ ┌─────────────────────────────┐     │
│ │ 210                          │     │  ← 自動入力（変更可）
│ └─────────────────────────────┘     │
│                                     │
│        [キャンセル]  [保存]          │
└─────────────────────────────────────┘
```

**プリセット一覧:**
- **らくらくメルカリ便**: ネコポス(¥210), 宅急便コンパクト(¥450), 宅急便60(¥750), 宅急便80(¥850), 宅急便100(¥1,050), 宅急便120(¥1,200), 宅急便140(¥1,450), 宅急便160(¥1,700), 宅急便180(¥2,100), 宅急便200(¥2,500)
- **ゆうゆうメルカリ便**: ゆうパケットポストmini(¥160), ゆうパケットポスト(¥215), ゆうパケットプラス(¥455), ゆうパック60(¥750), ゆうパック80(¥870), ゆうパック100(¥1,070), ゆうパック120(¥1,200), ゆうパック140(¥1,450), ゆうパック160(¥1,700), ゆうパック170(¥1,900)
- **梱包・発送たのメル便**: 80サイズ(¥1,700), 120サイズ(¥2,400), 160サイズ(¥3,400), 200サイズ(¥5,000), 250サイズ(¥8,600), 300サイズ(¥12,000), 350サイズ(¥18,500), 400サイズ(¥25,400), 450サイズ(¥33,000)
- **ゆうメール**: 150g以内(¥180), 250g以内(¥215), 500g以内(¥310), 1kg以内(¥360)
- **レターパック**: ライト(¥0), プラス(¥0) ※送料ではなく梱包資材として計上
- **普通郵便（定形郵便）**: 50g以内(¥110), 50g以内（規格外）(¥140), 100g以内（規格内）(¥180), 150g以内（規格内）(¥270), 250g以内（規格内）(¥320), 500g以内（規格内）(¥510), 1kg以内（規格内）(¥750)
- **普通郵便（定形外郵便）**: 50g以内（規格外）(¥260), 100g以内（規格外）(¥290), 150g以内（規格外）(¥390), 250g以内（規格外）(¥450), 500g以内（規格外）(¥660), 1kg以内（規格外）(¥920), 2kg以内（規格外）(¥1,350), 4kg以内（規格外）(¥1,750)
- **クリックポスト**: クリックポスト(¥185)
- **ゆうパケット**: 厚さ1cm以内(¥250), 厚さ2cm以内(¥310), 厚さ3cm以内(¥360)
- **未定**: 未定(¥0)
- **その他**: フリー入力可能

#### 一覧表示（カテゴリ別アコーディオン）
```
┌─────────────────────────────────────────────┐
│ 🚚 発送方法マスタ管理           [+ 新規追加] │
├─────────────────────────────────────────────┤
│ ▼ らくらくメルカリ便（3件）                  │
│   ┌───────────────────────────────────┐     │
│   │ ネコポス              ¥210  [編集][削除]│
│   │ 宅急便コンパクト      ¥450  [編集][削除]│
│   │ 宅急便60             ¥750  [編集][削除]│
│   └───────────────────────────────────┘     │
│                                             │
│ ▼ ゆうゆうメルカリ便（3件）                  │
│   ┌───────────────────────────────────┐     │
│   │ ゆうパケットポストmini ¥160 [編集][削除]│
│   │ ゆうパケットポスト    ¥215  [編集][削除]│
│   │ ゆうパケットプラス    ¥455  [編集][削除]│
│   └───────────────────────────────────┘     │
│                                             │
│ ▼ レターパック（2件）                        │
│   ┌───────────────────────────────────┐     │
│   │ ライト               ¥0    [編集][削除]│
│   │ プラス               ¥0    [編集][削除]│
│   └───────────────────────────────────┘     │
└─────────────────────────────────────────────┘
```

### 📍 関連ファイル
- `shipping_method_master_ui.html` - UI修正
- `shipping_method_master_manager.js` - バックエンド（修正不要）

### 🧪 テストケース

#### TC-INV-004-UI-001: プリセット選択での新規追加
**前提条件:**
- 発送方法マスタ管理画面を開く

**実行操作:**
1. [+ 新規追加] ボタンをクリック
2. カテゴリで「らくらくメルカリ便」を選択
3. 詳細で「ネコポス」を選択

**期待結果:**
- 送料欄に「210」が自動入力される
- 保存後、一覧の「らくらくメルカリ便」セクションに追加される

#### TC-INV-004-UI-002: カテゴリ別アコーディオン表示
**前提条件:**
- 複数カテゴリの発送方法が登録済み

**実行操作:**
1. 発送方法マスタ管理画面を開く
2. 「らくらくメルカリ便」セクションを確認

**期待結果:**
- らくらくメルカリ便の発送方法のみがグループ化されて表示される
- アコーディオンで開閉可能

#### TC-INV-004-UI-003: その他（フリー入力）
**前提条件:**
- 発送方法マスタ管理画面を開く

**実行操作:**
1. [+ 新規追加] ボタンをクリック
2. カテゴリで「その他」を選択
3. 発送方法1: 「佐川急便」、発送方法2: 「飛脚宅配便60」、送料: 「800」を手動入力

**期待結果:**
- フリーテキスト入力が可能
- 一覧の「その他」セクションに追加される

### ✏️ 実装内容

#### Phase 1: プリセット選択式UI ⏳ 未着手
- [ ] プリセットデータ定義（JavaScript配列）
- [ ] カテゴリプルダウン実装
- [ ] 詳細プルダウン実装（カテゴリ連動）
- [ ] 送料自動入力実装
- [ ] 「その他」選択時のフリー入力対応

#### Phase 2: カテゴリ別アコーディオン表示 ⏳ 未着手
- [ ] 一覧データをカテゴリ別にグループ化
- [ ] Bootstrap Accordionで実装
- [ ] カテゴリごとの件数表示

#### Phase 3: テスト ⏳ 未着手
- [ ] TC-INV-004-UI-001 実行
- [ ] TC-INV-004-UI-002 実行
- [ ] TC-INV-004-UI-003 実行
- [ ] デグレード確認（既存機能）

### 📝 テスト結果
- [ ] TC-INV-004-UI-001: PASS / FAIL
- [ ] TC-INV-004-UI-002: PASS / FAIL
- [ ] TC-INV-004-UI-003: PASS / FAIL
- [ ] デグレード確認: OK / NG

### 状態
- [ ] ✅ DONE (完了日: )

### 📌 備考
- Phase 1完了後に実装
- Phase 2（SaaS化）での地域別料金表対応も見据えた設計
- メルカリ便は全国一律料金（Phase 1で対応）
- 通常の宅急便・ゆうパックは地域別料金（Phase 2で対応予定）

---

## INV-004-LOT | 機能追加: 梱包資材のロット管理（FIFO方式）

### 📌 基本情報
- [ ] カテゴリ: 機能追加（原価管理精度向上）
- [ ] 優先度: 高
- [ ] 影響範囲: 備品在庫リスト、販売記録、利益計算
- [ ] 要望日: 2025-10-28

### 💡 要望内容

梱包資材の価格変動に対応し、入庫ロットごとに単価を管理する**FIFO（先入先出）方式**を実装する。

**背景:**
- 梱包資材の価格は変動する（例: A4ジッパー袋 939円 → 1000円）
- 現在の設計: 全在庫が最新単価で計算される（誤差が発生）
- 年間数千〜数万商品では誤差が累積（年間¥3,000〜¥15,000以上）
- **正確な原価管理はSaaS化での競合優位性**

**問題シナリオ:**
1. 10月1日: A4ジッパー袋 100枚 @9.39円を購入
2. 10月15日: 85枚使用、残り15枚（@9.39円）
3. 10月20日: A4ジッパー袋 100枚 @10.00円を購入
4. **現在の問題**: 残り15枚も10.00円/枚で計算される ❌
5. **正しい計算**: 残り15枚は9.39円、新しい100枚は10.00円 ✅

### ✅ 期待動作

#### FIFO（先入先出）方式
- 古いロットから順番に使う
- ロットごとに単価と残数を管理
- 販売記録時、最も古いロットの単価を使用

**具体例:**
```
入庫履歴:
- 2025-10-01: A4ジッパー袋 100枚 @9.39円 → 残数: 15枚
- 2025-10-20: A4ジッパー袋 100枚 @10.00円 → 残数: 100枚

販売記録時（FIFO）:
1. 商品販売（A4ジッパー袋を1枚使用）
2. 最も古いロット（10/1入庫）から使用 → 単価: 9.39円
3. 残数を14に更新
4. 15枚使い切ったら、次のロット（10/20入庫）から使用 → 単価: 10.00円
```

### 📍 関連ファイル
- 新規シート: **入庫履歴**（ロット管理）
- 既存シート: **備品在庫リスト**（在庫集計のみ）
- `inventory.js` - 販売記録API修正（FIFO単価取得）
- `packaging_materials_manager.js` - 入庫履歴管理API（新規）
- `packaging_materials_ui.html` - 入庫時のロット登録UI

### 🏗️ 設計

#### データ構造

##### 新規シート: 入庫履歴

| 列名 | 説明 | 例 |
|------|------|-----|
| 入庫日 | 入庫した日付 | 2025-10-01 |
| 略称 | 梱包資材の略称 | A4ジ |
| 商品名 | 梱包資材の商品名 | A4ジッパー袋 |
| 入庫数 | 入庫した個数 | 100 |
| 単価 | 1個あたりの単価 | 9.39 |
| 残数 | 現在の残数（出庫のたびに減る） | 15 |
| 備考 | メモ | - |

**初期データ移行:**
- 既存の「備品在庫リスト」から入庫履歴を生成
- 1ロットとして登録（入庫日: システム稼働日、残数: 現在の在庫数）

##### 既存シート: 備品在庫リスト（変更点）

**変更なし（そのまま使用）:**
- 在庫集計（入庫数合計、出庫数合計、在庫数）
- 「1個あたり」列は参考値として残す（最新の平均単価）

**データソース:**
- 入庫数合計: 入庫履歴の合計
- 出庫数合計: 出庫履歴の合計
- 在庫数: 入庫数合計 - 出庫数合計

#### API設計

##### 入庫処理API（新規）
```javascript
/**
 * 梱包資材の入庫処理（ロット登録）
 * @param {string} abbreviation - 略称
 * @param {number} quantity - 入庫数
 * @param {number} unitCost - 単価
 * @param {string} date - 入庫日（省略時は今日）
 */
function addPackagingMaterialLotAPI(abbreviation, quantity, unitCost, date) {
  // 入庫履歴シートに新規行追加
  // 残数 = 入庫数（初期値）
}
```

##### 出庫処理API（FIFO）（修正）
```javascript
/**
 * 梱包資材の出庫処理（FIFO方式）
 * @param {string} abbreviation - 略称
 * @param {number} quantity - 出庫数（通常1）
 * @return {number} unitCost - 使用した単価
 */
function consumePackagingMaterialFIFO(abbreviation, quantity) {
  // 1. 入庫履歴シートから、該当略称の残数>0のロットを取得（入庫日昇順）
  const lots = getLotsByAbbreviation(abbreviation); // [{date, unitCost, remaining}, ...]

  // 2. 在庫不足チェック
  const totalRemaining = lots.reduce((sum, lot) => sum + lot.remaining, 0);
  if (totalRemaining < quantity) {
    throw new Error('在庫不足');
  }

  // 3. FIFO処理
  let remainingToConsume = quantity;
  let totalCost = 0;

  for (const lot of lots) {
    if (remainingToConsume <= 0) break;

    const consumeFromThisLot = Math.min(lot.remaining, remainingToConsume);

    // 単価計算
    totalCost += consumeFromThisLot * lot.unitCost;

    // 残数更新
    updateLotRemaining(lot.rowIndex, lot.remaining - consumeFromThisLot);

    remainingToConsume -= consumeFromThisLot;
  }

  // 4. 平均単価を返す（通常は quantity = 1 なので、最も古いロットの単価）
  return totalCost / quantity;
}
```

##### 販売記録API（修正）
```javascript
// saveSalesRecordAPI 内の修正
for (const material of salesData.packagingMaterials) {
  // 旧: 固定単価を使用
  // sheet.getRange(targetRow, costCol).setValue(material.unitCost);

  // 新: FIFO方式で実際の単価を取得
  const actualUnitCost = consumePackagingMaterialFIFO(material.abbreviation, 1);
  sheet.getRange(targetRow, costCol).setValue(actualUnitCost);
}
```

#### UI設計

##### 梱包資材マスタ管理UI（追加機能）

**入庫ボタンの追加:**
```
┌───────────────────────────────────────┐
│ A4ジッパー袋                          │
│ 略称: A4ジ                            │
│ 在庫数: 115個 🟢                      │
│ 現在の平均単価: ¥9.92                 │
│                                       │
│ [編集] [削除] [➕ 入庫登録]          │ ← 新規追加
└───────────────────────────────────────┘
```

**入庫登録モーダル:**
```
┌─────────────────────────────────┐
│ 📦 入庫登録: A4ジッパー袋        │
├─────────────────────────────────┤
│ 入庫日:                          │
│ ┌───────────────────────────┐   │
│ │ 2025-10-28                │   │
│ └───────────────────────────┘   │
│                                 │
│ 入庫数:                          │
│ ┌───────────────────────────┐   │
│ │ 100                       │   │
│ └───────────────────────────┘   │
│                                 │
│ 単価（1個あたり）:                │
│ ┌───────────────────────────┐   │
│ │ 10.00                     │   │
│ └───────────────────────────┘   │
│                                 │
│ 備考:                            │
│ ┌───────────────────────────┐   │
│ │ Amazon購入                │   │
│ └───────────────────────────┘   │
│                                 │
│      [キャンセル]  [登録]        │
└─────────────────────────────────┘
```

**入庫履歴の表示（オプション）:**
```
▼ 入庫履歴を表示

┌─────────────────────────────────────────────┐
│ 入庫日      | 入庫数 | 単価  | 残数 | 備考  │
├─────────────────────────────────────────────┤
│ 2025-10-01 | 100   | 9.39  | 15   | -     │
│ 2025-10-20 | 100   | 10.00 | 100  | -     │
└─────────────────────────────────────────────┘
```

### 🧪 テストケース

#### TC-INV-004-LOT-001: 入庫履歴の初期移行
**前提条件:**
- 備品在庫リストに既存データあり（A4ジッパー袋: 在庫数100、単価9.39円）

**実行操作:**
1. 入庫履歴シート作成スクリプトを実行
2. 既存データを移行

**期待結果:**
- 入庫履歴シートに1行追加される
- 入庫日: システム稼働日、略称: A4ジ、入庫数: 100、単価: 9.39、残数: 100

#### TC-INV-004-LOT-002: 新規入庫登録
**前提条件:**
- A4ジッパー袋の入庫履歴: 残数15（@9.39円）

**実行操作:**
1. 梱包資材マスタ管理で「A4ジッパー袋」の [入庫登録] ボタンをクリック
2. 入庫数: 100、単価: 10.00 を入力
3. 登録ボタンをクリック

**期待結果:**
- 入庫履歴シートに新規行追加（入庫数: 100、単価: 10.00、残数: 100）
- 備品在庫リストの在庫数が 15 → 115 に更新される

#### TC-INV-004-LOT-003: FIFO方式での出庫（古いロット消費）
**前提条件:**
- A4ジッパー袋の入庫履歴:
  - ロット1: 残数15（@9.39円）
  - ロット2: 残数100（@10.00円）

**実行操作:**
1. 商品を販売（A4ジッパー袋を1枚使用）
2. 販売記録を保存

**期待結果:**
- 梱包資材費に **9.39円** が記録される（古いロットから使用）
- 入庫履歴のロット1の残数が 15 → 14 に更新される
- ロット2の残数は100のまま（未使用）

#### TC-INV-004-LOT-004: FIFO方式での出庫（ロット切り替え）
**前提条件:**
- A4ジッパー袋の入庫履歴:
  - ロット1: 残数1（@9.39円）
  - ロット2: 残数100（@10.00円）

**実行操作:**
1. 商品を2件販売（A4ジッパー袋を2枚使用）

**期待結果:**
- 1件目: 梱包資材費 **9.39円**（ロット1から使用）
- ロット1の残数: 1 → 0
- 2件目: 梱包資材費 **10.00円**（ロット2に切り替え）
- ロット2の残数: 100 → 99

#### TC-INV-004-LOT-005: 在庫不足エラー
**前提条件:**
- A4ジッパー袋の入庫履歴: 残数0

**実行操作:**
1. 商品を販売（A4ジッパー袋を選択）
2. 保存ボタンをクリック

**期待結果:**
- エラーメッセージ表示: 「在庫不足: A4ジッパー袋」
- 販売記録は保存されない

### ✏️ 実装内容

#### Phase 1: データ構造構築 ⏳ 未着手
- [ ] 入庫履歴シート作成
- [ ] 既存データの初期移行スクリプト
- [ ] テストデータ投入

#### Phase 2: FIFO出庫処理 ⏳ 未着手
- [ ] `consumePackagingMaterialFIFO` 実装（inventory.js）
- [ ] `getLotsByAbbreviation` 実装
- [ ] `updateLotRemaining` 実装
- [ ] `saveSalesRecordAPI` 修正（FIFO単価使用）

#### Phase 3: 入庫登録UI ⏳ 未着手
- [ ] `addPackagingMaterialLotAPI` 実装（packaging_materials_manager.js）
- [ ] 入庫登録モーダルUI（packaging_materials_ui.html）
- [ ] 入庫履歴表示UI

#### Phase 4: テスト ⏳ 未着手
- [ ] TC-INV-004-LOT-001 実行
- [ ] TC-INV-004-LOT-002 実行
- [ ] TC-INV-004-LOT-003 実行
- [ ] TC-INV-004-LOT-004 実行
- [ ] TC-INV-004-LOT-005 実行
- [ ] デグレード確認

### 📝 テスト結果
- [ ] TC-INV-004-LOT-001: PASS / FAIL
- [ ] TC-INV-004-LOT-002: PASS / FAIL
- [ ] TC-INV-004-LOT-003: PASS / FAIL
- [ ] TC-INV-004-LOT-004: PASS / FAIL
- [ ] TC-INV-004-LOT-005: PASS / FAIL
- [ ] デグレード確認: OK / NG

### 💡 コスト削減効果

**シナリオ: 年間10,000商品販売**
- 梱包資材: 袋、テープ、緩衝材（3種類）
- 平均誤差: 0.3円/個 × 3種類 = 0.9円/商品

**誤差累積:**
- 現在（単一単価）: 年間 ±¥9,000の誤差
- FIFO方式: **誤差ほぼゼロ**

**SaaS化での価値:**
- 正確な原価管理 → **顧客の信頼獲得**
- 競合他社（単一単価）との差別化
- 大量販売事業者への訴求力向上

### 状態
- [ ] ✅ DONE (完了日: )

### 📌 備考
- INV-004テスト完了後に実装開始
- Phase 1の最重要機能の1つ
- SaaS化での競合優位性を生む

---

## INV-004-COL | バグ修正: 梱包資材列不足（4個以上の梱包資材が保存できない）

### 📌 基本情報
- [ ] カテゴリ: バグ修正
- [ ] 優先度: 中
- [ ] 影響範囲: 在庫/売上管理表、販売記録API
- [ ] 発見日: 2025-10-28

### 🐛 問題内容

販売記録モーダルで梱包資材を4個以上追加できるが、「在庫/売上管理表」シートには3列までしかないため、4個目以降が保存できない。

**症状:**
- UIでは [+ 梱包資材を追加] で4個、5個と追加可能
- 保存時、梱包資材4以降がシートに書き込まれない（データ欠損）
- エラーも表示されず、ユーザーが気づきにくい

**再現手順:**
1. 販売記録モーダルを開く
2. [+ 梱包資材を追加] を2回クリック（梱包資材4、5を追加）
3. 梱包資材1〜5を全て選択
4. 保存
5. スプレッドシートを確認 → 梱包資材1〜3のみ記録されている

### ✅ 期待動作

- 梱包資材を最大10個まで追加・保存可能
- シートに対応する列（梱包資材4〜10、梱包費4〜10）が存在する
- 4個以上追加した場合も正常に保存される

### 📍 関連ファイル
- スプレッドシート: **在庫/売上管理表**（列追加が必要）
- `inventory.js` - saveSalesRecordAPI（最大数を10に変更）

### 🔍 根本原因

#### 1. シート構造の制限
**現在の列構成:**
```
梱包資材1 | 梱包費1 | 梱包資材2 | 梱包費2 | 梱包資材3 | 梱包費3
```

**必要な列構成:**
```
梱包資材1 | 梱包費1 | ... | 梱包資材10 | 梱包費10
```

#### 2. APIの制限
**inventory.js Line 2176（saveSalesRecordAPI）:**
```javascript
// 梱包資材を書き込み（最大3個想定）
for (let i = 0; i < salesData.packagingMaterials.length && i < 3; i++) {
  // ...
}
```

**問題点:**
- `i < 3` でループを3回までに制限
- 4個目以降は無視される
- エラーログもない

### 💡 修正案

#### 修正1: シートに列を追加

**在庫/売上管理表シート:**
- 梱包資材4〜10列を追加（計14列追加）
- 梱包費4〜10列を追加

**挿入位置:**
- 梱包資材3列の後ろに追加

#### 修正2: APIの最大数を変更

**inventory.js Line 2176:**
```javascript
// 旧: i < 3
for (let i = 0; i < salesData.packagingMaterials.length && i < 3; i++) {

// 新: i < 10
for (let i = 0; i < salesData.packagingMaterials.length && i < 10; i++) {
```

#### 修正3: バリデーション追加

10個を超える場合はエラー表示:
```javascript
if (salesData.packagingMaterials.length > 10) {
  return {
    success: false,
    message: '梱包資材は最大10個までです'
  };
}
```

### 🧪 テストケース

#### TC-INV-004-COL-001: 梱包資材4個の保存
**前提条件:**
- 在庫/売上管理表に梱包資材4〜10列が追加済み

**実行操作:**
1. 販売記録モーダルを開く
2. [+ 梱包資材を追加] をクリック
3. 梱包資材1〜4を全て選択
4. 保存

**期待結果:**
- スプレッドシートに梱包資材1〜4、梱包費1〜4が全て記録される

#### TC-INV-004-COL-002: 梱包資材10個の保存
**前提条件:**
- 在庫/売上管理表に梱包資材4〜10列が追加済み

**実行操作:**
1. 販売記録モーダルを開く
2. [+ 梱包資材を追加] を7回クリック（梱包資材10まで追加）
3. 梱包資材1〜10を全て選択
4. 保存

**期待結果:**
- スプレッドシートに梱包資材1〜10、梱包費1〜10が全て記録される

#### TC-INV-004-COL-003: 11個目の追加（エラー表示）
**前提条件:**
- 販売記録モーダルが開いている

**実行操作:**
1. [+ 梱包資材を追加] を10回クリック（梱包資材11まで追加しようとする）

**期待結果:**
- エラーメッセージ表示: 「梱包資材は最大10個までです」
- 11個目は追加されない

### ✏️ 修正内容

#### Phase 1: シート列追加 ⏳ 未着手
- [ ] 在庫/売上管理表に梱包資材4〜10列を追加
- [ ] 在庫/売上管理表に梱包費4〜10列を追加
- [ ] 既存データへの影響確認

#### Phase 2: API修正 ⏳ 未着手
- [ ] inventory.js saveSalesRecordAPI のループ上限を10に変更
- [ ] 11個目以降のバリデーション追加
- [ ] エラーメッセージ表示

#### Phase 3: UI修正（オプション） ⏳ 未着手
- [ ] 10個目で [+ 梱包資材を追加] ボタンを無効化
- [ ] または、10個超えた際にアラート表示

#### Phase 4: テスト ⏳ 未着手
- [ ] TC-INV-004-COL-001 実行
- [ ] TC-INV-004-COL-002 実行
- [ ] TC-INV-004-COL-003 実行
- [ ] デグレード確認（既存の3個以下のケース）

### 📝 テスト結果
- [ ] TC-INV-004-COL-001: PASS / FAIL
- [ ] TC-INV-004-COL-002: PASS / FAIL
- [ ] TC-INV-004-COL-003: PASS / FAIL
- [ ] デグレード確認: OK / NG

### 状態
- [ ] ✅ DONE (完了日: )

### 📌 備考
- Phase 1では3個で運用し、Phase 2以降で10個対応も可
- 実際に4個以上使うケースがどれくらいあるか検証が必要
- SaaS化を見据えると、10個対応は必須

---

## INV-005 | 機能追加: 在庫管理検索UI改善（管理番号検索強化）

### 📌 基本情報
- [ ] カテゴリ: 機能追加・改善
- [ ] 優先度: 中
- [ ] 影響範囲: 在庫管理画面（検索UI）
- [ ] 要望日: 2025-10-27

### 💡 要望内容

在庫管理画面の検索UIを改善し、管理番号による商品検索を使いやすくする。

**背景:**
- 現在: テキスト入力のみ（「AA-1016」と手入力が必要）
- 課題: 入力が面倒、管理番号のカスタマイズ設定との連携なし
- 要望: 商品登録のように使いやすい検索UI

**設計方針:**
- **案A採用**: シンプル＋実用的アプローチ
- クイック検索（全体検索・入力補完）
- 詳細検索（前方一致・後方一致・部分一致）
- 将来的に動的セグメント生成を追加可能な設計

### ✅ 期待動作

**クイック検索:**
- 管理番号入力欄に「AA」と入力 → 「AA-1001, AA-1002...」が候補表示
- 部分一致対応（「AA」だけで検索可能）
- オートコンプリート機能（既存の管理番号から候補生成）

**詳細検索（アコーディオン展開）:**
- 管理番号（前方一致）: 「AA-」と入力 → AA-で始まる商品を検索
- 管理番号（後方一致）: 「-001」と入力 → -001で終わる商品を検索
- 管理番号（部分一致）: 「251007」と入力 → 251007を含む商品を検索

**UI構成:**
```
┌─────────────────────────────────────────┐
│ 🔍 管理番号で検索                       │
│ ┌─────────────────────────────────┐     │
│ │ AA-1016                         │     │
│ └─────────────────────────────────┘     │
│ 候補: AA-1001, AA-1002, AA-1003...     │
└─────────────────────────────────────────┘

▼ 詳細検索を開く
┌─────────────────────────────────────────┐
│ 前方一致: [AA-]                         │
│ 後方一致: [-001]                        │
│ 部分一致: [251007]                      │
│                                         │
│ [検索] [クリア]                         │
└─────────────────────────────────────────┘
```

### 📍 関連ファイル
- `sidebar_inventory.html` - 在庫管理UI（検索セクション）
- `inventory.js` - searchInventoryAPI（検索ロジック拡張）

### 🧪 テストケース

#### TC-INV-005-001: クイック検索（全体一致）
**前提条件:**
- 管理番号「AA-1016」の商品が存在

**実行操作:**
1. クイック検索欄に「AA-1016」と入力
2. Enter または検索ボタンをクリック

**期待結果:**
- AA-1016の商品が表示される

#### TC-INV-005-002: クイック検索（部分一致）
**前提条件:**
- AA-1001, AA-1002, AA-1003, BB-1001が存在

**実行操作:**
1. クイック検索欄に「AA」と入力
2. 検索実行

**期待結果:**
- AA-で始まる3件（AA-1001, AA-1002, AA-1003）のみ表示
- BB-1001は表示されない

#### TC-INV-005-003: オートコンプリート
**前提条件:**
- AA-1001, AA-1002, AA-1003が存在

**実行操作:**
1. クイック検索欄に「AA-」と入力
2. 候補リストを確認

**期待結果:**
- 候補リストに「AA-1001」「AA-1002」「AA-1003」が表示される

#### TC-INV-005-004: 詳細検索（前方一致）
**前提条件:**
- AA-1001, AB-1001, BA-1001が存在

**実行操作:**
1. 詳細検索を展開
2. 「前方一致」欄に「AA-」と入力
3. 検索実行

**期待結果:**
- AA-1001のみ表示
- AB-1001, BA-1001は表示されない

#### TC-INV-005-005: 詳細検索（後方一致）
**前提条件:**
- AA-1001, BB-1001, AA-2001が存在

**実行操作:**
1. 詳細検索を展開
2. 「後方一致」欄に「-1001」と入力
3. 検索実行

**期待結果:**
- AA-1001, BB-1001の2件が表示
- AA-2001は表示されない

#### TC-INV-005-006: 詳細検索（部分一致）
**前提条件:**
- K-251007-001, AA-251007-050, BB-251008-001が存在

**実行操作:**
1. 詳細検索を展開
2. 「部分一致」欄に「251007」と入力
3. 検索実行

**期待結果:**
- K-251007-001, AA-251007-050の2件が表示
- BB-251008-001は表示されない

### ✏️ 実装内容

#### Phase 1: UI実装 ⏳ 未着手
- [ ] クイック検索欄の追加
- [ ] 詳細検索アコーディオンの実装
- [ ] オートコンプリート機能の実装
- [ ] Bootstrap UI統一（商品登録と同じスタイル）

#### Phase 2: バックエンドAPI拡張 ⏳ 未着手
- [ ] searchInventoryAPI拡張
  - [ ] 前方一致検索パラメータ追加
  - [ ] 後方一致検索パラメータ追加
  - [ ] 部分一致検索パラメータ追加
- [ ] オートコンプリート用API（getManagementNumberSuggestionsAPI）
  - [ ] 既存管理番号の取得
  - [ ] 前方一致候補生成

#### Phase 3: テスト ⏳ 未着手
- [ ] TC-INV-005-001 実行
- [ ] TC-INV-005-002 実行
- [ ] TC-INV-005-003 実行
- [ ] TC-INV-005-004 実行
- [ ] TC-INV-005-005 実行
- [ ] TC-INV-005-006 実行
- [ ] デグレード確認（既存検索機能）

### 📝 テスト結果
- [ ] TC-INV-005-001: PASS / FAIL
- [ ] TC-INV-005-002: PASS / FAIL
- [ ] TC-INV-005-003: PASS / FAIL
- [ ] TC-INV-005-004: PASS / FAIL
- [ ] TC-INV-005-005: PASS / FAIL
- [ ] TC-INV-005-006: PASS / FAIL
- [ ] デグレード確認: OK / NG

### 状態
- [ ] ✅ DONE (完了日: )

### 📌 備考
- 将来的な拡張: 動的セグメント生成（管理番号カスタマイズ設定に応じたUI自動生成）
- 実装時間見積もり: 2〜3時間
- 優先度: 中（INV-004テスト完了後に実施）

---

## INV-001 | 機能追加: Phase 1 在庫管理システム実装

### 📌 基本情報
- [ ] カテゴリ: 機能追加
- [ ] 優先度: 高
- [ ] 影響範囲: 在庫管理（新規機能）
- [ ] 要望日: 2025-10-24

### 💡 要望内容

Phase 1の在庫管理システムを実装する。以下の機能を含む：

**実装する機能**:
1. 在庫検索・絞り込み機能
2. 商品複製機能（メルカリ再出品、類似商品登録）
3. 在庫状況ダッシュボード
4. ステータス手動変更
5. 出品前商品の編集
6. 画像差し替え

**実装しない機能（Phase 2以降）**:
- 出品後商品の全項目編集
- 複数プラットフォーム管理
- 一括価格変更

### ✅ 期待動作

**在庫検索・絞り込み**:
- ステータス、ブランド、カテゴリ、サイズ、カラー等で絞り込み可能
- 一覧表示（カード形式、50件/ページ）
- ソート機能（登録日時、出品日、販売日、利益金額）

**商品複製**:
- 既存商品データを全コピー
- 管理番号のみ新規採番
- ステータスを「登録済み」にリセット
- 商品登録フォームを開く（データ入力済み）

**在庫状況ダッシュボード**:
- ステータス別件数表示
- 総在庫金額、総出品金額、総販売金額、総利益金額
- 平均在庫日数

### 📍 関連ファイル
- `inventory.js` (在庫管理バックエンド)
- `sidebar_inventory.html` (在庫管理UI)
- `INVENTORY_MANAGEMENT_DESIGN.md` (設計書)

### 🧪 テストケース

#### TC-INV-001-001: 在庫検索（ステータス絞り込み）
**前提条件:**
- スプレッドシートに複数ステータスの商品が存在
  - 登録済み: 5件
  - 出品中: 10件
  - 販売済み: 20件

**実行操作:**
1. 在庫管理画面を開く
2. ステータスフィルタで「出品中」を選択
3. 検索ボタンをクリック

**期待結果:**
- 「出品中」の商品10件のみが表示される
- 他のステータスの商品は表示されない

#### TC-INV-001-002: 商品複製
**前提条件:**
- 管理番号 AA-1001 の商品が存在
- 次の管理番号は AA-1002

**実行操作:**
1. 在庫一覧で AA-1001 の「複製」ボタンをクリック
2. 商品登録フォームが開く
3. そのまま「登録」ボタンをクリック

**期待結果:**
- 新しい商品が AA-1002 として登録される
- AA-1001 のデータ（ブランド、カテゴリ等）が全てコピーされている
- ステータスは「登録済み」
- 出品日、販売日はクリアされている

#### TC-INV-001-003: 在庫状況ダッシュボード
**前提条件:**
- 登録済み: 5件（仕入金額合計: 10,000円）
- 出品中: 10件（仕入金額合計: 50,000円、出品金額合計: 100,000円）
- 販売済み: 20件（販売金額合計: 500,000円、利益金額合計: 200,000円）

**実行操作:**
1. 在庫管理画面を開く
2. ダッシュボードを表示

**期待結果:**
- ステータス別件数が正しく表示される
  - 登録済み: 5件
  - 出品中: 10件
  - 販売済み: 20件
- 総在庫金額: 60,000円
- 総出品金額: 100,000円
- 総販売金額: 500,000円
- 総利益金額: 200,000円

### ✏️ 実装内容

#### Phase 1-1: 在庫検索・絞り込み機能 ✅ 完了
- [x] バックエンド関数実装（`inventory.js`）
  - [x] `searchInventoryAPI(params)` - 検索・絞り込み（ページネーション、ソート、詳細フィルタ対応）
  - [x] `getStatisticsAPI(params)` - 統計情報取得（新ステータス対応）
- [x] フロントエンド実装（`sidebar_inventory.html`）
  - [x] 検索フォームUI
  - [x] フィルタUI（ステータス複数選択、ブランド、カテゴリ、サイズ、カラー、テキスト検索）
  - [x] 一覧表示UI（カード形式、レスポンシブ）
  - [x] ページネーション
  - [x] ソート機能
- [ ] TC-INV-001-001 実行（次回テスト予定）

#### Phase 1-2: 商品複製機能 ✅ 完了
- [x] バックエンド関数実装（`inventory.js`）
  - [x] `duplicateProductAPI(params)` - 商品複製
- [x] フロントエンド実装（`sidebar_inventory.html`）
  - [x] 「複製」ボタン追加
  - [x] 複製処理実装
- [ ] TC-INV-001-002 実行（次回テスト予定）

#### Phase 1-3: 在庫状況ダッシュボード ✅ 完了
- [x] バックエンド関数実装（`inventory.js`）
  - [x] `getStatisticsAPI(params)` - 統計情報取得
- [x] フロントエンド実装（`sidebar_inventory.html`）
  - [x] ダッシュボードUI（ステータス別件数、総利益、平均在庫日数）
  - [x] 統計情報表示
- [ ] TC-INV-001-003 実行（次回テスト予定）

#### Phase 1-4: その他機能
- [x] ステータス手動変更機能（実装完了 2025-10-26）
  - 商品詳細モーダルでステータス選択可能
  - updateProductStatusAPIとの連携
  - 全ステータス間の手動変更に対応
- [x] 出品前商品の編集機能（実装完了 2025-10-26）
  - 「登録済み」「出品準備中」のみ編集可能
  - 編集可能フィールド: ブランド、商品名、カテゴリ、アイテム、サイズ、カラー、素材、商品説明、仕入金額、出品金額
  - 変更フィールドの自動検出と一括更新
  - updateProductAPIとの連携
- [ ] 画像差し替え機能（Phase 2以降に実施 - 別Issue化予定）

### 📝 テスト結果
- [ ] TC-INV-001-001: PASS / FAIL
- [ ] TC-INV-001-002: PASS / FAIL
- [ ] TC-INV-001-003: PASS / FAIL
- [ ] デグレード確認（商品登録機能）: OK / NG

### 状態
- [ ] ✅ DONE (完了日: )

---

---

## 🔧 技術的負債・リファクタリング（Technical Debt）

**現在の技術的負債: 0件**

---

**総Issue数: 8件**
**最終更新: 2025-10-28**
