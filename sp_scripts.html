<script>
  // ==================== デバッグ設定 ====================
  // 本番環境ではfalseに設定してログを無効化
  const DEBUG_MODE = true;

  // デバッグ用ログユーティリティ
  const debug = {
    log: (...args) => { if (DEBUG_MODE) console.log(...args); },
    warn: (...args) => { if (DEBUG_MODE) console.warn(...args); },
    error: (...args) => { console.error(...args); }, // エラーは常に表示
    info: (...args) => { if (DEBUG_MODE) console.info(...args); }
  };

  // ==================== 定数定義 ====================
  const NAME_LIMIT = 40;
  const NAME_LIMIT_MODE = 'warn';
  const DESC_LIMIT = 1000;
  const DESC_LIMIT_MODE = 'warn';

  // AI生成文を保存するグローバル変数
  let AI_GENERATED_TEXT = '';

  // 設定マスタ全体をキャッシュ
  let CACHED_CONFIG = null;

  // ==================== テーマの即座適用（ちらつき防止） ====================
  // ページ読み込み直後にLocalStorageからテーマを復元
  (function() {
    try {
      const cachedTheme = localStorage.getItem('rebornTheme');
      if (cachedTheme && cachedTheme !== 'casual') {
        document.body.classList.add('theme-' + cachedTheme);
        console.log('🚀 LocalStorageからテーマを即座に適用:', cachedTheme);
      }
    } catch (e) {
      console.warn('LocalStorageアクセスエラー:', e);
    }
  })();

  // テーマをLocalStorageに保存
  function saveThemeToLocalStorage(theme) {
    try {
      localStorage.setItem('rebornTheme', theme);
      console.log('💾 テーマをLocalStorageに保存:', theme);
    } catch (e) {
      console.warn('LocalStorage保存エラー:', e);
    }
  }

  // 設定マスタ全体を読み込む
  function loadAllConfig() {
    if (google && google.script && google.script.run) {
      google.script.run
        .withSuccessHandler(function(config) {
          if (config) {
            CACHED_CONFIG = config;
            console.log('設定マスタ全体を読み込みました:', config);

            // デザインテーマを適用
            if (config.デザインテーマ) {
              const theme = config.デザインテーマ;
              console.log('✅ デザインテーマを読み込みました:', theme);

              // LocalStorageに保存
              saveThemeToLocalStorage(theme);

              // テーマクラスを適用（LocalStorageと異なる場合のみ）
              if (theme !== 'casual') {
                const themeClass = 'theme-' + theme;
                if (!document.body.classList.contains(themeClass)) {
                  document.body.classList.add(themeClass);
                  console.log('✅ テーマクラスを追加:', themeClass);
                }
              } else {
                // カジュアルテーマに戻す場合は全テーマクラスを削除
                document.body.classList.remove('theme-modern');
                console.log('ℹ️ カジュアルテーマ（デフォルト）を使用');
              }
            } else {
              console.log('⚠️ デザインテーマ設定が見つかりません。デフォルト（casual）を使用します。');
            }
          }
        })
        .withFailureHandler(function(error) {
          console.error('設定マスタ読み込みエラー:', error);
        })
        .loadConfigMaster();
    }
  }

  // 配送デフォルト設定（設定マスタから読み込む）
  let SHIPPING_DEFAULTS = {
    '配送料の負担': '送料込み(出品者負担)',
    '配送の方法': 'ゆうゆうメルカリ便',
    '発送元の地域': '岡山県',
    '発送までの日数': '1~2日で発送'
  };

  // 設定マスタから配送デフォルトを読み込む
  function loadShippingDefaults() {
    if (google && google.script && google.script.run) {
      google.script.run
        .withSuccessHandler(function(config) {
          if (config) {
            SHIPPING_DEFAULTS = config;
            console.log('配送デフォルト設定を読み込みました:', config);
            // デフォルト値を適用
            applyShippingDefaults();
          }
        })
        .withFailureHandler(function(error) {
          console.error('配送デフォルト設定読み込みエラー:', error);
        })
        .getShippingDefaults();
    }
  }

  // 仕入・出品デフォルト設定（設定マスタから読み込む）
  let PROCURE_LISTING_DEFAULTS = {
    '仕入日_今日': false,
    'デフォルト仕入日': '',
    'デフォルト仕入先': '',
    '出品日_今日': false,
    'デフォルト出品日': '',
    'デフォルト出品先': ''
  };

  // 設定マスタから仕入・出品デフォルトを読み込む
  function loadProcureListingDefaults() {
    if (google && google.script && google.script.run) {
      google.script.run
        .withSuccessHandler(function(config) {
          if (config) {
            PROCURE_LISTING_DEFAULTS = config;
            console.log('仕入・出品デフォルト設定を読み込みました:', config);
            // デフォルト値を適用
            applyProcureListingDefaults();
          }
        })
        .withFailureHandler(function(error) {
          console.error('仕入・出品デフォルト設定読み込みエラー:', error);
        })
        .getProcureListingDefaults();
    }
  }
  const REQUIRED = [];
  
  const FIELD_IDS = [
  '管理番号','担当者',
  'セールスワード(カテゴリ)','セールスワード',
  'ブランド(英語)','ブランド(カナ)',
  '商品名(タイトル)',
  '大分類(カテゴリ)','中分類(カテゴリ)','小分類(カテゴリ)','細分類(カテゴリ)','細分類2',
  'サイズ','商品の状態',
  'アイテム名',
  // '商品の説明', // リセット時にクリアしない（updateDescriptionFromDetailで更新）
  '商品状態詳細',
  'サイズ(表記)','サイズ(表記)_靴','その他のサイズ表記_靴','普段のサイズ_靴','フィット感_靴',
  '肩幅','身幅','袖丈','着丈','ウエスト','ヒップ','股上','股下',
  '仕入日','仕入先','仕入金額',
  '出品日','出品先','出品金額',
  '配送料の負担','配送の方法','発送元の地域','発送までの日数'
];

  let CAT_ROWS = [];
  let BRAND_EN = [];
  let BRAND_KANA = [];
  let MASTER_OPTIONS = {}; // マスターオプションを保存

  // ブランドペアデータ（英語名とカナ読みの正確な対応関係）
  let BRAND_PAIRS = [];

  // ブランドデータの高速検索用インデックスマップ（ペア用）
  let BRAND_INDEX_MAP = new Map();

  // セールスワードデータ保存用
  let SALESWORD_DATA = {
    categories: [],
    wordsByCategory: {},
    allWords: []
  };

  // セールスワード表示形式設定
  let SALESWORD_FORMAT = {
    globalPrefix: '【',
    globalSuffix: '】',
    wordOverrides: []
  };

  // デフォルトセールスワード設定
  let defaultSalesword = null;

  // 商品状態履歴保持用
  let CONDITION_HISTORY = [];

  // 商品の状態別のクイック挿入ボタン定義（設定マスタから読み込む）
  let CONDITION_BUTTONS = {};

  // 商品名ブロックの並び順（設定マスタから読み込む）
  let TITLE_BLOCK_ORDER = ['salesword', 'brand', 'item', 'attribute'];

  // 設定マスタから商品名ブロックの並び順を読み込む
  function loadTitleBlockOrder() {
    if (google && google.script && google.script.run) {
      google.script.run
        .withSuccessHandler(function(order) {
          if (order && Array.isArray(order)) {
            // 'item'が含まれていない古い設定の場合は、brandの後に挿入
            if (!order.includes('item')) {
              const brandIndex = order.indexOf('brand');
              if (brandIndex !== -1) {
                order.splice(brandIndex + 1, 0, 'item');
              } else {
                // brandもない場合はデフォルト順序を使用
                order = ['salesword', 'brand', 'item', 'attribute'];
              }
              console.log('商品名ブロック並び順に item を追加しました:', order);
              // 更新した並び順を保存
              saveTitleBlockOrder();
            }
            TITLE_BLOCK_ORDER = order;
            console.log('商品名ブロックの並び順を読み込みました:', order);
            applyTitleBlockOrder();
          }
        })
        .withFailureHandler(function(error) {
          console.error('商品名ブロック並び順読み込みエラー:', error);
        })
        .getTitleBlockOrder();
    }
  }

  // 設定マスタから商品状態ボタンを読み込む
  function loadConditionButtonsFromConfig() {
    if (google && google.script && google.script.run) {
      google.script.run
        .withSuccessHandler(function(buttons) {
          if (buttons) {
            CONDITION_BUTTONS = buttons;
            console.log('商品状態ボタン設定を読み込みました:', Object.keys(CONDITION_BUTTONS).length, '種類');
            // 既に商品の状態が選択されている場合はボタンを更新
            updateConditionButtons();
          }
        })
        .withFailureHandler(function(error) {
          console.error('商品状態ボタン設定読み込みエラー:', error);
        })
        .getConditionButtons();
    }
  }

  // 素材システム用のグローバル変数
  let materialCount = 1;
  let MATERIAL_LOCATIONS = [];
  let MATERIAL_TYPES = [];

  // カラーシステム用のグローバル変数
  let colorCount = 1;
  let COLOR_OPTIONS = [];

  // 素材マスタデータの取得と設定
  function initializeMaterialMasters() {
    if (google && google.script && google.script.run) {
      google.script.run
        .withSuccessHandler(function(opts) {
          MATERIAL_LOCATIONS = opts['素材(箇所)'] || [];
          MATERIAL_TYPES = opts['素材(種類)'] || [];

          populateMaterialSelects(1);

          console.log('素材マスタ取得完了 - 箇所:', MATERIAL_LOCATIONS.length, '種類:', MATERIAL_TYPES.length);
        })
        .withFailureHandler(function(error) {
          console.error('素材マスタ取得エラー:', error);
        })
        .getMasterOptions();
    }
  }

  // カラーマスタデータの取得と設定
  function initializeColorMasters() {
    if (google && google.script && google.script.run) {
      google.script.run
        .withSuccessHandler(function(opts) {
          COLOR_OPTIONS = opts['カラー/配色/トーン'] || [];

          populateColorSelect(1);

          console.log('カラーマスタ取得完了:', COLOR_OPTIONS.length);
        })
        .withFailureHandler(function(error) {
          console.error('カラーマスタ取得エラー:', error);
        })
        .getMasterOptions();
    }
  }

  // セレクトボックスにマスタデータを設定
  function populateMaterialSelects(index) {
    const locationSelect = document.getElementById(`素材${index}_箇所`);
    const type1Select = document.getElementById(`素材${index}_種類1`);
    const type2Select = document.getElementById(`素材${index}_種類2`);
    const percent1Select = document.getElementById(`素材${index}_％1`);
    const percent2Select = document.getElementById(`素材${index}_％2`);

    if (locationSelect) {
      locationSelect.innerHTML = '<option value="">--</option>';
      MATERIAL_LOCATIONS.forEach(loc => {
        locationSelect.insertAdjacentHTML('beforeend', `<option value="${loc}">${loc}</option>`);
      });
    }

    if (type1Select) {
      type1Select.innerHTML = '<option value="">--</option>';
      MATERIAL_TYPES.forEach(type => {
        type1Select.insertAdjacentHTML('beforeend', `<option value="${type}">${type}</option>`);
      });
    }

    if (type2Select) {
      type2Select.innerHTML = '<option value="">--</option>';
      MATERIAL_TYPES.forEach(type => {
        type2Select.insertAdjacentHTML('beforeend', `<option value="${type}">${type}</option>`);
      });
    }

    // 割合のプルダウンを0-100で初期化
    if (percent1Select) {
      percent1Select.innerHTML = '<option value="">--%</option>';
      for (let i = 0; i <= 100; i++) {
        percent1Select.insertAdjacentHTML('beforeend', `<option value="${i}">${i}%</option>`);
      }
    }

    if (percent2Select) {
      percent2Select.innerHTML = '<option value="">--%</option>';
      for (let i = 0; i <= 100; i++) {
        percent2Select.insertAdjacentHTML('beforeend', `<option value="${i}">${i}%</option>`);
      }
    }
  }

  // 素材セットを追加
  function addMaterial() {
    if (materialCount >= 10) {
      alert('素材は最大10個まで追加できます');
      return;
    }

    materialCount++;

    const materialList = document.getElementById('materialList');
    const newItem = document.createElement('div');
    newItem.className = 'material-item';
    newItem.setAttribute('data-index', materialCount);

    newItem.innerHTML = `
      <div class="material-header">
        <span>素材 ${materialCount}</span>
        <button type="button" class="remove-material-btn" onclick="removeMaterial(${materialCount})">削除</button>
      </div>
      
      <div class="material-fields">
        <label>箇所:
          <select id="素材${materialCount}_箇所" class="material-location">
            <option value="">--</option>
          </select>
        </label>
        
        <div class="material-composition">
          <div class="composition-row">
            <label>種類:
              <select id="素材${materialCount}_種類1" class="material-type">
                <option value="">--</option>
              </select>
            </label>
            <label>割合:
              <select id="素材${materialCount}_％1" class="material-percent">
                <option value="">--%</option>
              </select>
            </label>
          </div>

          <div class="composition-row">
            <label>種類:
              <select id="素材${materialCount}_種類2" class="material-type">
                <option value="">--</option>
              </select>
            </label>
            <label>割合:
              <select id="素材${materialCount}_％2" class="material-percent">
                <option value="">--%</option>
              </select>
            </label>
          </div>
        </div>
      </div>
    `;

    materialList.appendChild(newItem);
    populateMaterialSelects(materialCount);
    updateRemoveButtons();
  }

  // 素材セットを削除
  function removeMaterial(index) {
    const item = document.querySelector(`.material-item[data-index="${index}"]`);
    if (item) {
      item.remove();

      const items = document.querySelectorAll('.material-item');
      materialCount = items.length;

      items.forEach((item, i) => {
        const newIndex = i + 1;
        item.setAttribute('data-index', newIndex);
        item.querySelector('.material-header span').textContent = `素材 ${newIndex}`;

        // onclickも更新
        const removeBtn = item.querySelector('.remove-material-btn');
        if (removeBtn) {
          removeBtn.onclick = () => removeMaterial(newIndex);
        }
      });

      updateRemoveButtons();
      updateDescriptionFromDetail(); // 素材情報更新
    }
  }

  // 削除ボタンの表示制御
  function updateRemoveButtons() {
    const items = document.querySelectorAll('.material-item');
    items.forEach(item => {
      const btn = item.querySelector('.remove-material-btn');
      if (btn) {
        btn.style.display = items.length > 1 ? 'block' : 'none';
      }
    });
  }

  // ========== カラー動的追加機能 ==========

  // カラーセレクトボックスにマスタデータを設定
  function populateColorSelect(index) {
    const colorSelect = document.getElementById(`カラー${index}`);

    if (colorSelect) {
      colorSelect.innerHTML = '<option value="">--</option>';
      COLOR_OPTIONS.forEach(color => {
        colorSelect.insertAdjacentHTML('beforeend', `<option value="${color}">${color}</option>`);
      });

      // 変更時にプレビューを更新
      colorSelect.addEventListener('change', updateDescriptionFromDetail);
    }
  }

  // カラーを追加
  function addColor() {
    if (colorCount >= 5) {
      alert('カラーは最大5個まで追加できます');
      return;
    }

    colorCount++;

    const colorList = document.getElementById('colorList');
    const newItem = document.createElement('div');
    newItem.className = 'color-item';
    newItem.setAttribute('data-index', colorCount);

    newItem.innerHTML = `
      <div class="color-header">
        <span>カラー ${colorCount}</span>
        <button type="button" class="remove-color-btn" onclick="removeColor(${colorCount})">削除</button>
      </div>

      <div class="color-fields">
        <label>色:
          <select id="カラー${colorCount}" class="color-select">
            <option value="">--</option>
          </select>
        </label>
      </div>
    `;

    colorList.appendChild(newItem);
    populateColorSelect(colorCount);
    updateColorRemoveButtons();
  }

  // カラーを削除
  function removeColor(index) {
    const item = document.querySelector(`.color-item[data-index="${index}"]`);
    if (item) {
      item.remove();

      const items = document.querySelectorAll('.color-item');
      colorCount = items.length;

      items.forEach((item, i) => {
        const newIndex = i + 1;
        item.setAttribute('data-index', newIndex);
        item.querySelector('.color-header span').textContent = `カラー ${newIndex}`;

        // onclickも更新
        const removeBtn = item.querySelector('.remove-color-btn');
        if (removeBtn) {
          removeBtn.onclick = () => removeColor(newIndex);
        }

        // selectのIDも更新
        const select = item.querySelector('.color-select');
        if (select) {
          const oldId = select.id;
          const oldValue = select.value;
          select.id = `カラー${newIndex}`;
          select.value = oldValue; // 選択値を保持
        }
      });

      updateColorRemoveButtons();
      updateDescriptionFromDetail(); // カラー情報更新
    }
  }

  // カラー削除ボタンの表示制御
  function updateColorRemoveButtons() {
    const items = document.querySelectorAll('.color-item');
    items.forEach(item => {
      const btn = item.querySelector('.remove-color-btn');
      if (btn) {
        btn.style.display = items.length > 1 ? 'block' : 'none';
      }
    });
  }

  // ========== 商品属性動的追加機能 ==========
  let attributeCount = 1;

  // カテゴリの選択肢を生成
  function getAttributeCategoryOptions() {
    const categories = [
      '生地・素材・質感系', '季節感・機能性', '着用シーン・イベント', '見た目・印象',
      'トレンド表現', 'サイズ感・体型カバー', '年代・テイスト・スタイル', 'カラー/配色/トーン',
      '柄・模様', 'ディテール・仕様', 'シルエット/ライン', 'ネックライン',
      '襟・衿', '袖・袖付け', '丈', '革/加工', '毛皮/加工', '生産国'
    ];
    let options = '<option value="">--選択してください--</option>';
    categories.forEach(cat => {
      options += `<option value="${cat}">${cat}</option>`;
    });
    return options;
  }

  // 商品属性のカテゴリプルダウンに選択肢を設定
  function populateAttributeCategory(index) {
    const categorySelect = document.getElementById(`商品属性${index}_カテゴリ`);
    if (categorySelect) {
      categorySelect.innerHTML = getAttributeCategoryOptions();
    }
  }

  // 商品属性セットを追加
  function addAttribute() {
    if (attributeCount >= 10) {
      alert('商品属性は最大10個まで追加できます');
      return;
    }

    attributeCount++;

    const attributeList = document.getElementById('attributeList');
    const newItem = document.createElement('div');
    newItem.className = 'attribute-item';
    newItem.setAttribute('data-index', attributeCount);

    newItem.innerHTML = `
      <div class="attribute-header">
        <span>属性 ${attributeCount}</span>
        <button type="button" class="remove-attribute-btn" onclick="removeProductAttribute(${attributeCount})">削除</button>
      </div>

      <div class="row" style="margin-top: 6px;">
        <div>
          <label>カテゴリ</label>
          <select id="商品属性${attributeCount}_カテゴリ">
            <option value="">--選択してください--</option>
          </select>
        </div>
        <div>
          <label>値</label>
          <select id="商品属性${attributeCount}_値" disabled>
            <option value="">--カテゴリを選択してください--</option>
          </select>
        </div>
      </div>
    `;

    attributeList.appendChild(newItem);
    populateAttributeCategory(attributeCount);
    setupAttributeSelector(attributeCount);
    updateAttributeRemoveButtons();
    updateAttributeFields();
  }

  // 商品属性セットを削除
  function removeProductAttribute(index) {
    const item = document.querySelector(`.attribute-item[data-index="${index}"]`);
    if (item) {
      item.remove();

      const items = document.querySelectorAll('.attribute-item');
      attributeCount = items.length;

      items.forEach((item, i) => {
        const newIndex = i + 1;
        item.setAttribute('data-index', newIndex);
        item.querySelector('.attribute-header span').textContent = `属性 ${newIndex}`;

        // onclickも更新
        const removeBtn = item.querySelector('.remove-attribute-btn');
        if (removeBtn) {
          removeBtn.onclick = () => removeProductAttribute(newIndex);
        }
      });

      updateAttributeRemoveButtons();
      updateAttributeFields();
      updateNamePreview();
    }
  }

  // 削除ボタンの表示制御
  function updateAttributeRemoveButtons() {
    const items = document.querySelectorAll('.attribute-item');
    items.forEach(item => {
      const btn = item.querySelector('.remove-attribute-btn');
      if (btn) {
        btn.style.display = (items.length > 1) ? 'block' : 'none';
      }
    });
  }

  // NAME_REST_FIELDS配列を更新（商品名プレビュー用）
  function updateAttributeFields() {
    const items = document.querySelectorAll('.attribute-item');
    NAME_REST_FIELDS.length = 0; // 配列をクリア
    items.forEach((item, i) => {
      NAME_REST_FIELDS.push(`商品属性${i + 1}_値`);
    });
  }

  // 単一の商品属性セレクターをセットアップ
  function setupAttributeSelector(index) {
    const categorySelect = document.getElementById(`商品属性${index}_カテゴリ`);
    const valueSelect = document.getElementById(`商品属性${index}_値`);

    if (categorySelect && valueSelect) {
      categorySelect.addEventListener('change', function() {
        updateAttributeValues(`商品属性${index}_カテゴリ`, `商品属性${index}_値`);
      });

      valueSelect.addEventListener('change', updateNamePreview);
    }
  }

  // 商品の状態に応じてボタンを表示切替
  function updateConditionButtons() {
    const conditionSelect = document.getElementById('商品の状態');
    const container = document.getElementById('quickInsertButtonsContainer');

    if (!conditionSelect || !container) {
      console.log('商品の状態またはボタンコンテナが見つかりません');
      return;
    }

    const conditionValue = conditionSelect.value;
    const buttons = CONDITION_BUTTONS[conditionValue] || [];

    // コンテナをクリア
    container.innerHTML = '';

    // ボタンが存在しない場合は非表示
    if (buttons.length === 0) {
      container.style.display = 'none';
      return;
    }

    container.style.display = '';

    // ボタンを生成
    buttons.forEach(btn => {
      const button = document.createElement('button');
      button.type = 'button';
      button.className = 'quick-btn';
      button.textContent = btn.label;
      button.setAttribute('data-text', btn.text);

      // クリックイベント
      button.addEventListener('click', function() {
        const textarea = document.getElementById('商品状態詳細');
        if (!textarea) return;

        const text = this.getAttribute('data-text');

        // ボタンを押すと常に置き換え（上書き）
        textarea.value = text;

        // 商品の説明を更新
        if (typeof updateDescriptionFromDetail === 'function') {
          updateDescriptionFromDetail();
        }
      });

      container.appendChild(button);
    });

    console.log('クイック挿入ボタン表示更新:', buttons.length, '個');
  }

  // クイック挿入ボタンのイベントリスナー設定
  function setupQuickInsertButtons() {
    // 初期化時に商品の状態に応じてボタンを表示
    updateConditionButtons();
    console.log('クイック挿入ボタン初期化完了');
  }

  // 商品状態詳細オートコンプリート機能
  function attachConditionSuggest(inputId, list) {
    const input = document.getElementById(inputId);
    const panel = document.getElementById('suggest-' + inputId);

    if (!input || !panel) {
      console.log(`商品状態詳細オートコンプリート: 要素が見つかりません ${inputId}`);
      return;
    }

    let activeIndex = -1;
    const limit = 10;

    const render = (items) => {
      panel.innerHTML = '';
      if (!items.length) {
        panel.innerHTML = '<div class="sug-empty">候補なし</div>';
        panel.hidden = false;
        return;
      }

      items.slice(0, limit).forEach((v, i) => {
        const div = document.createElement('div');
        div.className = 'sug-item';
        div.textContent = v;

        div.addEventListener('mousemove', () => {
          Array.from(panel.querySelectorAll('.sug-item')).forEach(x => x.classList.remove('active'));
          div.classList.add('active');
          activeIndex = i;
        });

        div.addEventListener('mousedown', (e) => {
          e.preventDefault();
        });

        div.addEventListener('click', () => {
          input.value = v;
          hide();
          if (typeof updateDescriptionFromDetail === 'function') {
            updateDescriptionFromDetail();
          }
        });

        panel.appendChild(div);
      });

      panel.hidden = false;
    };

    const hide = () => {
      panel.hidden = true;
      activeIndex = -1;
    };

    const hideLater = () => setTimeout(hide, 100);

    const doFilter = () => {
      const q = (input.value || '').trim();

      if (!Array.isArray(list) || list.length === 0 || !q || q.length < 2) {
        hide();
        return;
      }

      // 部分一致検索（大文字小文字を区別しない）
      const qq = q.toLowerCase();
      const filtered = list.filter(v => {
        const s = String(v).toLowerCase();
        return s.indexOf(qq) !== -1;
      });

      console.log(`商品状態詳細候補: ${filtered.length}件`);
      render(filtered);
    };

    input.addEventListener('input', doFilter);
    input.addEventListener('focus', doFilter);
    input.addEventListener('blur', hideLater);

    input.addEventListener('keydown', (e) => {
      if (panel.hidden) return;
      const items = Array.from(panel.querySelectorAll('.sug-item'));
      if (!items.length) return;

      if (e.key === 'ArrowDown') {
        e.preventDefault();
        activeIndex = (activeIndex + 1) % items.length;
        items.forEach(x => x.classList.remove('active'));
        items[activeIndex].classList.add('active');
        items[activeIndex].scrollIntoView({ block: 'nearest' });
      } else if (e.key === 'ArrowUp') {
        e.preventDefault();
        activeIndex = (activeIndex - 1 + items.length) % items.length;
        items.forEach(x => x.classList.remove('active'));
        items[activeIndex].classList.add('active');
        items[activeIndex].scrollIntoView({ block: 'nearest' });
      } else if (e.key === 'Enter') {
        if (activeIndex >= 0) {
          e.preventDefault();
          input.value = items[activeIndex].textContent || '';
          hide();
          if (typeof updateDescriptionFromDetail === 'function') {
            updateDescriptionFromDetail();
          }
        }
      } else if (e.key === 'Escape') {
        hide();
      }
    });

    console.log('商品状態詳細オートコンプリート設定完了');
  }

  // ハッシュタグ設定（設定マスタから読み込む）
  let HASHTAG_CONFIG = {
    全商品プレフィックス: '#REBORN_',
    全商品テキスト: '全商品',
    ブランドプレフィックス: '#REBORN_',
    ブランドサフィックス: 'アイテム一覧',
    カテゴリプレフィックス: '#REBORN_',
    カテゴリサフィックス: '一覧'
  };

  // 設定マスタからハッシュタグ設定を読み込む
  function loadHashtagConfig() {
    if (google && google.script && google.script.run) {
      google.script.run
        .withSuccessHandler(function(config) {
          if (config) {
            HASHTAG_CONFIG = config;
            console.log('ハッシュタグ設定を読み込みました:', config);
            // ハッシュタグチェックボックスを生成
            renderHashtagCheckboxes();
            // 設定読み込み後、商品の説明を更新
            if (typeof updateDescriptionFromDetail === 'function') {
              updateDescriptionFromDetail();
            }
          }
        })
        .withFailureHandler(function(error) {
          console.error('ハッシュタグ設定読み込みエラー:', error);
        })
        .getHashtagConfig();
    }
  }

  /**
   * ハッシュタグチェックボックスを生成
   */
  function renderHashtagCheckboxes() {
    console.log('renderHashtagCheckboxes が呼び出されました');
    const container = document.getElementById('hashtagCheckboxContainer');
    if (!container) {
      console.error('hashtagCheckboxContainer が見つかりません');
      return;
    }

    container.innerHTML = '';

    console.log('HASHTAG_CONFIG:', HASHTAG_CONFIG);
    if (!HASHTAG_CONFIG || !HASHTAG_CONFIG.hashtags || HASHTAG_CONFIG.hashtags.length === 0) {
      console.warn('ハッシュタグ設定が空です');
      container.innerHTML = '<div style="font-size: 11px; color: #6b7280; text-align: center;">ハッシュタグ設定がありません</div>';
      return;
    }

    const hashtags = HASHTAG_CONFIG.hashtags;
    const commonPrefix = HASHTAG_CONFIG.commonPrefix || '#';

    hashtags.forEach((hashtag, index) => {
      const title = hashtag.title || '';
      const icon = hashtag.icon || '🏷️';
      const suffix = hashtag.suffix || '';

      // プレビューテキストを生成（実際の値は商品登録時に動的に変わる）
      let previewText = '';
      if (title === '全商品') {
        previewText = `${commonPrefix}${suffix}`;
      } else if (title === 'ブランド') {
        previewText = `${commonPrefix}ブランド名${suffix}`;
      } else if (title === 'カテゴリ') {
        const categoryOptions = hashtag.categoryOptions || [];
        const categoryPreview = categoryOptions.join('+');
        previewText = `${commonPrefix}${categoryPreview}${suffix}`;
      } else {
        previewText = `${commonPrefix}${suffix}`;
      }

      const checkboxId = `hashtag-checkbox-${index}`;

      console.log(`Creating checkbox ${index}:`, {title, icon, previewText});

      // シンプルに1行で表示
      const label = document.createElement('label');
      label.style.cssText = 'display: block; cursor: pointer; padding: 6px 4px; border-bottom: 1px solid #e5e7eb;';

      const checkbox = document.createElement('input');
      checkbox.type = 'checkbox';
      checkbox.id = checkboxId;
      checkbox.setAttribute('data-index', index);
      checkbox.checked = true;
      checkbox.onchange = updateDescriptionFromDetail;
      checkbox.style.cssText = 'cursor: pointer; margin-right: 6px; vertical-align: middle;';

      const textSpan = document.createElement('span');
      textSpan.style.cssText = 'font-size: 11px; color: #374151; vertical-align: middle;';
      textSpan.textContent = previewText;

      label.appendChild(checkbox);
      label.appendChild(textSpan);

      container.appendChild(label);
    });

    // 生成後のDOMを確認
    console.log('生成されたHTML:', container.innerHTML);
    console.log('チェックボックスコンテナの子要素数:', container.children.length);
  }

  /**
   * 折りたたみ機能
   */
  function toggleCollapse(sectionId) {
    const section = document.getElementById(sectionId);
    const toggleIcon = document.getElementById(sectionId.replace('Section', 'Toggle'));

    if (section && toggleIcon) {
      const isHidden = section.style.display === 'none';
      section.style.display = isHidden ? 'block' : 'none';
      toggleIcon.textContent = isHidden ? '▲' : '▼';
    }
  }

  /**
   * 割引情報チェックボックスを動的生成
   */
  function renderDiscountCheckboxes() {
    console.log('renderDiscountCheckboxes が呼び出されました');
    const container = document.getElementById('discountCheckboxContainer');
    if (!container) {
      console.error('discountCheckboxContainer が見つかりません');
      return;
    }

    container.innerHTML = '';

    console.log('DISCOUNT_CONFIG:', DISCOUNT_CONFIG);
    if (!DISCOUNT_CONFIG) {
      console.warn('割引設定が空です');
      container.innerHTML = '<div style="font-size: 11px; color: #6b7280; text-align: center;">割引設定がありません</div>';
      return;
    }

    const discounts = [];

    // フォロー割
    if (DISCOUNT_CONFIG['フォロー割'] && DISCOUNT_CONFIG['フォロー割'].length > 0) {
      discounts.push({
        id: 'follow',
        label: 'フォロー割',
        icon: '👥'
      });
    }

    // リピート割
    if (DISCOUNT_CONFIG['リピート割'] && DISCOUNT_CONFIG['リピート割'].length > 0) {
      discounts.push({
        id: 'repeat',
        label: 'リピート割',
        icon: '🔁'
      });
    }

    // まとめ割
    if (DISCOUNT_CONFIG['まとめ割'] && DISCOUNT_CONFIG['まとめ割'].length > 0) {
      discounts.push({
        id: 'matome',
        label: 'まとめ割',
        icon: '📦'
      });
    }

    if (discounts.length === 0) {
      container.innerHTML = '<div style="font-size: 11px; color: #6b7280; text-align: center;">割引設定がありません</div>';
      return;
    }

    // テーマチェック: モダンテーマの場合は絵文字を表示しない
    const isModernTheme = document.body.classList.contains('theme-modern');

    discounts.forEach((discount, index) => {
      const checkboxId = `discount-checkbox-${discount.id}`;

      const label = document.createElement('label');
      label.style.cssText = 'display: block; cursor: pointer; padding: 6px 4px; border-bottom: 1px solid #e5e7eb;';

      const checkbox = document.createElement('input');
      checkbox.type = 'checkbox';
      checkbox.id = checkboxId;
      checkbox.setAttribute('data-discount-type', discount.id);
      checkbox.checked = true;
      checkbox.onchange = updateDescriptionFromDetail;
      checkbox.style.cssText = 'cursor: pointer; margin-right: 6px; vertical-align: middle;';

      const textSpan = document.createElement('span');
      textSpan.style.cssText = 'font-size: 11px; color: #374151; vertical-align: middle;';
      textSpan.textContent = isModernTheme ? discount.label : `${discount.icon} ${discount.label}`;

      label.appendChild(checkbox);
      label.appendChild(textSpan);

      container.appendChild(label);
    });

    console.log('割引情報チェックボックス生成完了:', discounts.length);
  }

  /**
   * ハッシュタグチェックボックスのプレビューテキストを更新
   */
  function updateHashtagCheckboxPreviews() {
    if (!HASHTAG_CONFIG || !HASHTAG_CONFIG.hashtags) return;

    const hashtags = HASHTAG_CONFIG.hashtags;
    const commonPrefix = HASHTAG_CONFIG.commonPrefix || '#';

    hashtags.forEach((hashtag, index) => {
      const previewElement = document.getElementById(`hashtag-preview-${index}`);
      if (!previewElement) return;

      const title = hashtag.title || '';
      const suffix = hashtag.suffix || '';
      let previewText = '';

      if (title === '全商品') {
        previewText = `${commonPrefix}${suffix}`;
      } else if (title === 'ブランド') {
        const brandEn = _val('ブランド(英語)');
        const brandKana = _val('ブランド(カナ)');
        const brand = brandEn || brandKana;
        if (brand) {
          const cleanBrand = brand.replace(/\s+/g, '');
          previewText = `${commonPrefix}${cleanBrand}${suffix}`;
        } else {
          previewText = `${commonPrefix}ブランド名${suffix}`;
        }
      } else if (title === 'カテゴリ') {
        const categoryOptions = hashtag.categoryOptions || [];
        const categoryMap = {
          '大分類': _val('大分類(カテゴリ)'),
          '中分類': _val('中分類(カテゴリ)'),
          '小分類': _val('小分類(カテゴリ)'),
          '細分類1': _val('細分類(カテゴリ)'),
          '細分類2': _val('細分類2'),
          'アイテム名': _val('アイテム名')
        };

        const categoryParts = [];
        categoryOptions.forEach(optionName => {
          const value = categoryMap[optionName];
          if (value) {
            categoryParts.push(value);
          }
        });

        if (categoryParts.length > 0) {
          previewText = `${commonPrefix}${categoryParts.join('')}${suffix}`;
        } else {
          const categoryPreview = categoryOptions.join('+');
          previewText = `${commonPrefix}${categoryPreview}${suffix}`;
        }
      } else {
        previewText = `${commonPrefix}${suffix}`;
      }

      previewElement.textContent = previewText;
    });
  }

  // 割引情報設定（設定マスタから読み込む）
  let DISCOUNT_CONFIG = {
    'フォロー割': [
      { 範囲: '〜2,999円', 割引額: '100円引' },
      { 範囲: '〜5,999円', 割引額: '200円引' },
      { 範囲: '〜8,999円', 割引額: '300円引' },
      { 範囲: '9,000円〜', 割引額: '500円引' }
    ],
    'リピート割': [
      { 範囲: '', 割引額: '200円引' }
    ],
    'まとめ割': [
      { 範囲: '2点', 割引額: '300円' },
      { 範囲: '3点', 割引額: '500円' },
      { 範囲: '4点', 割引額: '1,000円' }
    ]
  };

  // 設定マスタから割引情報を読み込む
  function loadDiscountConfig() {
    if (google && google.script && google.script.run) {
      google.script.run
        .withSuccessHandler(function(config) {
          if (config) {
            DISCOUNT_CONFIG = config;
            console.log('割引情報設定を読み込みました:', Object.keys(config).length, '種類');
            // チェックボックスを生成
            renderDiscountCheckboxes();
            // 設定読み込み後、商品の説明を更新
            if (typeof updateDescriptionFromDetail === 'function') {
              updateDescriptionFromDetail();
            }
          }
        })
        .withFailureHandler(function(error) {
          console.error('割引情報設定読み込みエラー:', error);
        })
        .getDiscountConfig();
    }
  }

  // 割引情報テキストを生成（チェックボックス対応版）
  function generateDiscountInfo() {
    // 割引情報があるかチェック
    const hasFollow = DISCOUNT_CONFIG['フォロー割'] && DISCOUNT_CONFIG['フォロー割'].length > 0;
    const hasRepeat = DISCOUNT_CONFIG['リピート割'] && DISCOUNT_CONFIG['リピート割'].length > 0;
    const hasMatome = DISCOUNT_CONFIG['まとめ割'] && DISCOUNT_CONFIG['まとめ割'].length > 0;

    // チェックボックスの状態を確認
    const followCheckbox = document.getElementById('discount-checkbox-follow');
    const repeatCheckbox = document.getElementById('discount-checkbox-repeat');
    const matomeCheckbox = document.getElementById('discount-checkbox-matome');

    const includeFollow = hasFollow && (!followCheckbox || followCheckbox.checked);
    const includeRepeat = hasRepeat && (!repeatCheckbox || repeatCheckbox.checked);
    const includeMatome = hasMatome && (!matomeCheckbox || matomeCheckbox.checked);

    // すべての割引が空またはチェックなしの場合は空文字を返す
    if (!includeFollow && !includeRepeat && !includeMatome) {
      return '';
    }

    let text = '\n【お得な割引情報】\n\n';

    // テーマチェック: モダンテーマの場合は絵文字を表示しない
    const isModernTheme = document.body.classList.contains('theme-modern');
    const bullet = isModernTheme ? '' : '■ ';

    // フォロー割
    if (includeFollow) {
      text += `${bullet}フォロー割\n`;
      DISCOUNT_CONFIG['フォロー割'].forEach(item => {
        text += `${item.範囲} ⇒ ${item.割引額}\n`;
      });
      // 説明文があれば追加
      if (DISCOUNT_CONFIG['フォロー割_説明文']) {
        text += `${DISCOUNT_CONFIG['フォロー割_説明文']}\n`;
      }
      text += '\n';
    }

    // リピート割
    if (includeRepeat) {
      const repeatDiscount = DISCOUNT_CONFIG['リピート割'][0].割引額;
      text += `${bullet}リピート割\n`;
      text += `次回購入時に${repeatDiscount}\n`;
      // 説明文があれば追加
      if (DISCOUNT_CONFIG['リピート割_説明文']) {
        text += `${DISCOUNT_CONFIG['リピート割_説明文']}\n`;
      }
      text += '\n';
    }

    // まとめ割
    if (includeMatome) {
      text += `${bullet}まとめ割\n`;
      DISCOUNT_CONFIG['まとめ割'].forEach(item => {
        text += `${item.範囲}⇒${item.割引額}\n`;
      });
      // 説明文があれば追加
      if (DISCOUNT_CONFIG['まとめ割_説明文']) {
        text += `${DISCOUNT_CONFIG['まとめ割_説明文']}`;
      }
    }

    return text;
  }

  // オリジナルハッシュタグ生成関数（動的設定対応版・チェックボックス連動）
  function generateHashtags() {
    const tags = [];

    // 新形式（動的ハッシュタグ配列 + 共通プレフィックス）に対応
    if (HASHTAG_CONFIG.hashtags && Array.isArray(HASHTAG_CONFIG.hashtags)) {
      const commonPrefix = HASHTAG_CONFIG.commonPrefix || '';

      HASHTAG_CONFIG.hashtags.forEach((hashtag, index) => {
        // チェックボックスの状態を確認
        const checkbox = document.getElementById(`hashtag-checkbox-${index}`);
        if (!checkbox || !checkbox.checked) {
          return; // チェックされていない場合はスキップ
        }

        const suffix = hashtag.suffix || '';
        const title = hashtag.title || '';

        // タイトルに基づいて中間部分を決定
        if (title === '全商品') {
          // 全商品タグ
          tags.push(`${commonPrefix}${suffix}`);
        } else if (title === 'ブランド') {
          // ブランド別タグ（英語優先、なければカナ）
          const brandEn = _val('ブランド(英語)');
          const brandKana = _val('ブランド(カナ)');
          const brand = brandEn || brandKana;
          if (brand) {
            const cleanBrand = brand.replace(/\s+/g, '');
            tags.push(`${commonPrefix}${cleanBrand}${suffix}`);
          }
        } else if (title === 'カテゴリ') {
          // カテゴリタグ（選択されたカテゴリを連結）
          const categoryOptions = hashtag.categoryOptions || ['大分類', '中分類'];

          // カテゴリ値のマッピング
          const categoryMap = {
            '大分類': _val('大分類(カテゴリ)'),
            '中分類': _val('中分類(カテゴリ)'),
            '小分類': _val('小分類(カテゴリ)'),
            '細分類1': _val('細分類(カテゴリ)'),
            '細分類2': _val('細分類2'),
            'アイテム名': _val('アイテム名')
          };

          // 選択されたカテゴリを順番に連結
          const categoryParts = [];
          categoryOptions.forEach(optionName => {
            const value = categoryMap[optionName];
            if (value) {
              categoryParts.push(value);
            }
          });

          // 連結されたカテゴリでハッシュタグを生成
          if (categoryParts.length > 0) {
            const combinedCategory = categoryParts.join('');
            tags.push(`${commonPrefix}${combinedCategory}${suffix}`);
          }
        } else if (title === 'カラー') {
          // カラータグ
          const colorValue = _val('カラー');
          if (colorValue) {
            const cleanColor = colorValue.replace(/\s+/g, '');
            tags.push(`${commonPrefix}${cleanColor}${suffix}`);
          }
        } else if (title === 'サイズ') {
          // サイズタグ
          const sizeValue = _val('サイズ');
          if (sizeValue) {
            const cleanSize = sizeValue.replace(/\s+/g, '');
            tags.push(`${commonPrefix}${cleanSize}${suffix}`);
          }
        } else {
          // カスタムハッシュタグ（タイトルが特定のものでない場合）
          // 共通プレフィックスとサフィックスのみ結合
          if (commonPrefix || suffix) {
            tags.push(`${commonPrefix}${suffix}`);
          }
        }
      });
    } else {
      // 旧形式（固定3項目）との後方互換性
      // 全商品タグ
      if (HASHTAG_CONFIG.全商品プレフィックス || HASHTAG_CONFIG.全商品テキスト) {
        const allProductPrefix = HASHTAG_CONFIG.全商品プレフィックス || '#REBORN_';
        const allProductText = HASHTAG_CONFIG.全商品テキスト || '全商品';
        tags.push(`${allProductPrefix}${allProductText}`);
      }

      // ブランド別タグ
      const brandEn = _val('ブランド(英語)');
      if (brandEn && (HASHTAG_CONFIG.ブランドプレフィックス || HASHTAG_CONFIG.ブランドサフィックス)) {
        const brandPrefix = HASHTAG_CONFIG.ブランドプレフィックス || '#REBORN_';
        const brandSuffix = HASHTAG_CONFIG.ブランドサフィックス || 'アイテム一覧';
        const cleanBrand = brandEn.replace(/\s+/g, '');
        tags.push(`${brandPrefix}${cleanBrand}${brandSuffix}`);
      }

      // カテゴリタグ
      if (HASHTAG_CONFIG.カテゴリプレフィックス || HASHTAG_CONFIG.カテゴリサフィックス) {
        const categoryPrefix = HASHTAG_CONFIG.カテゴリプレフィックス || '#REBORN_';
        const categorySuffix = HASHTAG_CONFIG.カテゴリサフィックス || '一覧';

        const category1 = _val('大分類(カテゴリ)');
        const category2 = _val('中分類(カテゴリ)');

        if (category2) {
          tags.push(`${categoryPrefix}${category2}${categorySuffix}`);
        }
        if (category1) {
          tags.push(`${categoryPrefix}${category1}${categorySuffix}`);
        }
        if (category1 && category2) {
          tags.push(`${categoryPrefix}${category1}${category2}${categorySuffix}`);
        }
      }
    }

    // 重複削除
    return [...new Set(tags)];
  }

  function splitMulti(s) {
    return String(s||'').split(/[,\u3001\/\uFF0F\n]+/).map(v=>v.trim()).filter(v=>v.length>0);
  }

  function uniqKeepOrder(arr) {
    const s=new Set(), out=[];
    for(const x of arr||[]) {
      const v=(x??'').toString().trim();
      if(!v||s.has(v))continue;
      s.add(v);
      out.push(v);
    }
    return out;
  }

  // ブランドペアデータの高速検索用インデックスマップを構築
  function buildBrandIndexMap() {
    BRAND_INDEX_MAP.clear();

    // ペアデータから英語名をキーとしてマップを構築
    BRAND_PAIRS.forEach((pair, index) => {
      if (pair && pair.english) {
        BRAND_INDEX_MAP.set(pair.english, index);
      }
    });

    console.log(`ブランドペアインデックスマップ構築完了: ${BRAND_INDEX_MAP.size}件`);
    console.log('ブランドペアデータ数:', BRAND_PAIRS.length);
  }

  function fillSelectSafe(sel, values) {
    if (!sel) return;
    if (Array.isArray(values) && values.length) {
      const prev = sel.value;
      sel.innerHTML = '<option value="">--</option>';
      values.forEach(v=> sel.insertAdjacentHTML('beforeend', `<option value="${v}">${v}</option>`));
      sel.disabled = false;
      if (prev && values.includes(prev)) sel.value = prev;
    }
  }

  function resetSelect(id, disable=true) {
    const sel = document.getElementById(id);
    if (!sel) return;
    sel.innerHTML = '<option value="">--</option>';
    sel.value = '';
    if (disable) sel.disabled = true;
  }

  function applyShippingDefaults() {
    for (const k of Object.keys(SHIPPING_DEFAULTS)) {
      const el = document.getElementById(k);
      if (!el) continue;
      const def = SHIPPING_DEFAULTS[k];
      const exists = Array.from(el.options).some(o => String(o.value) === def);
      if (!exists) el.insertAdjacentHTML('beforeend', `<option value="${def}">${def}</option>`);
      el.value = def;
    }
  }

  function applyProcureListingDefaults() {
    const today = new Date().toISOString().split('T')[0]; // YYYY-MM-DD形式

    // デフォルト仕入日
    const procureDateField = document.getElementById('仕入日');
    if (procureDateField) {
      if (PROCURE_LISTING_DEFAULTS['仕入日_今日'] === true) {
        // 「常に今日」がチェックされている場合は今日の日付を使用
        procureDateField.value = today;
      } else {
        // 固定日付を使用
        const defaultProcureDate = PROCURE_LISTING_DEFAULTS['デフォルト仕入日'];
        if (defaultProcureDate) {
          procureDateField.value = defaultProcureDate;
        }
      }
    }

    // デフォルト仕入先
    const defaultProcureSource = PROCURE_LISTING_DEFAULTS['デフォルト仕入先'];
    if (defaultProcureSource) {
      const procureSourceField = document.getElementById('仕入先');
      if (procureSourceField) {
        // 選択肢に存在するか確認
        const exists = Array.from(procureSourceField.options).some(o => String(o.value) === defaultProcureSource);
        if (!exists) {
          procureSourceField.insertAdjacentHTML('beforeend', `<option value="${defaultProcureSource}">${defaultProcureSource}</option>`);
        }
        procureSourceField.value = defaultProcureSource;
      }
    }

    // デフォルト出品日
    const listingDateField = document.getElementById('出品日');
    if (listingDateField) {
      if (PROCURE_LISTING_DEFAULTS['出品日_今日'] === true) {
        // 「常に今日」がチェックされている場合は今日の日付を使用
        listingDateField.value = today;
      } else {
        // 固定日付を使用
        const defaultListingDate = PROCURE_LISTING_DEFAULTS['デフォルト出品日'];
        if (defaultListingDate) {
          listingDateField.value = defaultListingDate;
        }
      }
    }

    // デフォルト出品先
    const defaultListingDest = PROCURE_LISTING_DEFAULTS['デフォルト出品先'];
    if (defaultListingDest) {
      const listingDestField = document.getElementById('出品先');
      if (listingDestField) {
        // 選択肢に存在するか確認
        const exists = Array.from(listingDestField.options).some(o => String(o.value) === defaultListingDest);
        if (!exists) {
          listingDestField.insertAdjacentHTML('beforeend', `<option value="${defaultListingDest}">${defaultListingDest}</option>`);
        }
        listingDestField.value = defaultListingDest;
      }
    }
  }

  // ========== 管理番号セグメント方式UI ==========

  // 管理番号セグメントUIを初期化
  function initManagementNumberUI() {
    google.script.run
      .withSuccessHandler(function(segments) {
        if (!segments || segments.length === 0) {
          // セグメント設定がない場合は旧UIを使用
          initLegacyManagementUI();
          return;
        }

        renderManagementSegmentUI(segments);
      })
      .withFailureHandler(function(e) {
        console.error('セグメント設定の読み込みに失敗:', e);
        initLegacyManagementUI();
      })
      .getManagementNumberSegments();
  }

  // セグメントUIを生成
  function renderManagementSegmentUI(segments) {
    const container = document.getElementById('managementNumberFields');
    if (!container) return;

    container.innerHTML = '';

    // ユーザー入力が必要なセグメントがあるかチェック
    let hasUserInput = false;

    segments.forEach((segment, index) => {
      const type = segment.type;
      const config = segment.config;

      // ユーザー入力が必要なセグメントのみUIを生成
      switch (type) {
        case 'shelf':
          // 棚番号選択（2段階選択: 頭文字 → 棚番号）
          const shelfDiv = document.createElement('div');
          shelfDiv.style.marginBottom = '8px';

          // 頭文字の選択肢を生成（A-Z）
          let shelfFirstCharOptions = '<option value="">--選択--</option>';
          for (let i = 65; i <= 90; i++) {
            const char = String.fromCharCode(i);
            shelfFirstCharOptions += `<option value="${char}">${char}</option>`;
          }

          shelfDiv.innerHTML = `
            <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 8px;">
              <div>
                <label style="font-size: 12px; color: #6b7280; margin-bottom: 4px; display: block;">
                  頭文字
                </label>
                <select id="mgmt_shelf_first" class="tight" style="width: 100%;">
                  ${shelfFirstCharOptions}
                </select>
              </div>
              <div>
                <label style="font-size: 12px; color: #6b7280; margin-bottom: 4px; display: block;">
                  棚番号
                </label>
                <select id="mgmt_shelf_second" class="tight" style="width: 100%;">
                  <option value="">--選択--</option>
                </select>
              </div>
            </div>
          `;
          container.appendChild(shelfDiv);

          // 2文字目のイベントリスナーを先に設定
          const shelfSecondSelect = document.getElementById('mgmt_shelf_second');
          const updateShelfHandler = function() {
            updateManagementNumberPreview();
          };
          shelfSecondSelect.addEventListener('change', updateShelfHandler);

          // 頭文字選択時に2文字目を更新
          document.getElementById('mgmt_shelf_first').addEventListener('change', function() {
            const firstChar = this.value;

            // イベントリスナーを一時的に削除
            shelfSecondSelect.removeEventListener('change', updateShelfHandler);

            if (!firstChar) {
              shelfSecondSelect.innerHTML = '<option value="">--選択--</option>';
              shelfSecondSelect.disabled = true;
              shelfSecondSelect.value = '';
              // 頭文字が空の場合は管理番号をクリア
              setManagementNumber('', '未選択');
            } else {
              let secondOptions = '<option value="">--選択--</option>';
              for (let i = 65; i <= 90; i++) {
                const char = String.fromCharCode(i);
                secondOptions += `<option value="${char}">${firstChar}${char}</option>`;
              }
              shelfSecondSelect.innerHTML = secondOptions;
              shelfSecondSelect.value = '';  // 明示的に空欄に設定
              shelfSecondSelect.disabled = false;
              // 頭文字選択時はプレビュー更新しない（2文字目選択まで待つ）
              setManagementNumber('', '');
            }

            // イベントリスナーを再設定
            shelfSecondSelect.addEventListener('change', updateShelfHandler);
          });
          hasUserInput = true;
          break;

        case 'category':
          // カテゴリコード選択（AA〜ZZ）
          const categoryDiv = document.createElement('div');
          categoryDiv.style.marginBottom = '8px';

          // AA〜ZZの選択肢を生成
          let categoryOptions = '<option value="">--選択--</option>';
          for (let i = 65; i <= 90; i++) { // A-Z
            for (let j = 65; j <= 90; j++) { // A-Z
              const code = String.fromCharCode(i) + String.fromCharCode(j);
              categoryOptions += `<option value="${code}">${code}</option>`;
            }
          }

          categoryDiv.innerHTML = `
            <label style="font-size: 12px; color: #6b7280; margin-bottom: 4px; display: block;">
              📁 カテゴリコード
            </label>
            <select id="mgmt_category" class="tight" style="width: 100%;">
              ${categoryOptions}
            </select>
          `;
          container.appendChild(categoryDiv);

          // プレビュー更新イベント
          document.getElementById('mgmt_category').addEventListener('change', updateManagementNumberPreview);
          hasUserInput = true;
          break;

        case 'rank':
          // 品質ランク選択
          const rankDiv = document.createElement('div');
          rankDiv.style.marginBottom = '8px';
          rankDiv.innerHTML = `
            <label style="font-size: 12px; color: #6b7280; margin-bottom: 4px; display: block;">
              ⭐ 品質ランク
            </label>
            <select id="mgmt_rank" class="tight" style="width: 100%;">
              <option value="">--選択--</option>
              <option value="S">S (最高品質)</option>
              <option value="A">A (新品・美品)</option>
              <option value="B">B (良好)</option>
              <option value="C">C (使用感あり)</option>
              <option value="D">D (難あり)</option>
              <option value="E">E (ジャンク)</option>
            </select>
          `;
          container.appendChild(rankDiv);

          // プレビュー更新イベント
          document.getElementById('mgmt_rank').addEventListener('change', updateManagementNumberPreview);
          hasUserInput = true;
          break;

        case 'size':
          // サイズコード選択
          const sizeDiv = document.createElement('div');
          sizeDiv.style.marginBottom = '8px';
          sizeDiv.innerHTML = `
            <label style="font-size: 12px; color: #6b7280; margin-bottom: 4px; display: block;">
              📏 サイズコード
            </label>
            <select id="mgmt_size" class="tight" style="width: 100%;">
              <option value="">--選択--</option>
              <option value="XS">XS</option>
              <option value="S">S</option>
              <option value="M">M</option>
              <option value="L">L</option>
              <option value="XL">XL</option>
              <option value="XXL">XXL</option>
            </select>
          `;
          container.appendChild(sizeDiv);

          // プレビュー更新イベント
          document.getElementById('mgmt_size').addEventListener('change', updateManagementNumberPreview);
          hasUserInput = true;
          break;

        case 'color':
          // 色コード選択
          const colorDiv = document.createElement('div');
          colorDiv.style.marginBottom = '8px';
          colorDiv.innerHTML = `
            <label style="font-size: 12px; color: #6b7280; margin-bottom: 4px; display: block;">
              🎨 色コード
            </label>
            <select id="mgmt_color" class="tight" style="width: 100%;">
              <option value="">--選択--</option>
              <option value="BK">BK (黒)</option>
              <option value="W">W (白)</option>
              <option value="R">R (赤)</option>
              <option value="BL">BL (青)</option>
              <option value="GR">GR (緑)</option>
              <option value="Y">Y (黄)</option>
              <option value="G">G (グレー)</option>
              <option value="BR">BR (茶)</option>
              <option value="BE">BE (ベージュ)</option>
              <option value="P">P (ピンク)</option>
              <option value="O">O (オレンジ)</option>
            </select>
          `;
          container.appendChild(colorDiv);

          // プレビュー更新イベント
          document.getElementById('mgmt_color').addEventListener('change', updateManagementNumberPreview);
          hasUserInput = true;
          break;

        case 'custom':
          // カスタム値（2段階選択: 頭文字 → 棚番号）
          const customDiv = document.createElement('div');
          customDiv.style.marginBottom = '8px';

          // 頭文字の選択肢を生成（A-Z）
          let firstCharOptions = '<option value="">--選択--</option>';
          for (let i = 65; i <= 90; i++) {
            const char = String.fromCharCode(i);
            firstCharOptions += `<option value="${char}">${char}</option>`;
          }

          customDiv.innerHTML = `
            <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 8px;">
              <div>
                <label style="font-size: 12px; color: #6b7280; margin-bottom: 4px; display: block;">
                  頭文字
                </label>
                <select id="mgmt_custom_first" class="tight" style="width: 100%;">
                  ${firstCharOptions}
                </select>
              </div>
              <div>
                <label style="font-size: 12px; color: #6b7280; margin-bottom: 4px; display: block;">
                  棚番号
                </label>
                <select id="mgmt_custom_second" class="tight" style="width: 100%;">
                  <option value="">--選択--</option>
                </select>
              </div>
            </div>
          `;
          container.appendChild(customDiv);

          // 2文字目のイベントリスナーを先に設定
          const secondSelect = document.getElementById('mgmt_custom_second');
          const updateSecondHandler = function() {
            updateManagementNumberPreview();
          };
          secondSelect.addEventListener('change', updateSecondHandler);

          // 頭文字選択時に2文字目を更新
          document.getElementById('mgmt_custom_first').addEventListener('change', function() {
            const firstChar = this.value;

            // イベントリスナーを一時的に削除
            secondSelect.removeEventListener('change', updateSecondHandler);

            if (!firstChar) {
              secondSelect.innerHTML = '<option value="">--選択--</option>';
              secondSelect.disabled = true;
              secondSelect.value = '';
              // 頭文字が空の場合は管理番号をクリア
              setManagementNumber('', '未選択');
            } else {
              let secondOptions = '<option value="">--選択--</option>';
              for (let i = 65; i <= 90; i++) {
                const char = String.fromCharCode(i);
                secondOptions += `<option value="${char}">${firstChar}${char}</option>`;
              }
              secondSelect.innerHTML = secondOptions;
              secondSelect.value = '';  // 明示的に空欄に設定
              secondSelect.disabled = false;
              // 頭文字選択時はプレビュー更新しない（2文字目選択まで待つ）
              setManagementNumber('', '');
            }

            // イベントリスナーを再設定
            secondSelect.addEventListener('change', updateSecondHandler);
          });
          hasUserInput = true;
          break;

        case 'date':
        case 'sequence':
          // これらは自動生成なのでUIは不要
          break;
      }
    });

    // ユーザー入力が不要な場合（連番のみなど）は自動で管理番号を生成
    if (!hasUserInput) {
      updateManagementNumberPreview();
    } else {
      // 初期状態では管理番号フィールドを空欄にする
      setManagementNumber('', '未選択');
    }

    // UI生成完了後、表示する
    container.style.display = 'block';
    const previewSection = document.getElementById('managementNumberPreview');
    if (previewSection) {
      previewSection.style.display = 'block';
    }
  }

  // 管理番号プレビューを更新
  function updateManagementNumberPreview() {
    // 棚番号は2段階選択から結合
    const shelfFirst = _val('mgmt_shelf_first');
    const shelfSecond = _val('mgmt_shelf_second');
    const shelfValue = (shelfFirst && shelfSecond) ? shelfFirst + shelfSecond : '';

    // カスタム値は2段階選択から結合
    const customFirst = _val('mgmt_custom_first');
    const customSecond = _val('mgmt_custom_second');
    const customValue = (customFirst && customSecond) ? customFirst + customSecond : '';

    // 棚番号フィールドが存在する場合、2文字目が未選択なら採番しない
    const shelfFirstField = document.getElementById('mgmt_shelf_first');
    if (shelfFirstField && shelfFirst && !shelfSecond) {
      setManagementNumber('', '');
      return;
    }

    // カスタム値フィールドが存在する場合、2文字目が未選択なら採番しない
    const customFirstField = document.getElementById('mgmt_custom_first');
    if (customFirstField && customFirst && !customSecond) {
      setManagementNumber('', '');
      return;
    }

    const userInputs = {
      shelf: shelfValue,
      category: _val('mgmt_category'),
      rank: _val('mgmt_rank'),
      size: _val('mgmt_size'),
      color: _val('mgmt_color'),
      custom: customValue
    };

    // 採番中を表示
    setManagementNumber('', '採番中...');

    // 自動採番を実行
    google.script.run
      .withSuccessHandler(function(managementNumber) {
        if (typeof managementNumber === 'string' && managementNumber.startsWith('NG(')) {
          setManagementNumber('', managementNumber);
          return;
        }
        setManagementNumber(managementNumber, '');
      })
      .withFailureHandler(function(e) {
        console.error('管理番号生成エラー:', e);
        setManagementNumber('', 'エラー');
      })
      .generateSegmentBasedManagementNumber(userInputs);
  }

  // 管理番号の連番を調整（▲▼ボタン用）
  function adjustManagementNumber(delta) {
    const input = document.getElementById('管理番号');
    if (!input || !input.value) return;

    const currentValue = input.value;

    // 管理番号を分解（例：BB-1001 → prefix: 'BB-', number: 1001）
    const match = currentValue.match(/^(.*?)(\d+)$/);
    if (!match) return;

    const prefix = match[1]; // 例：'BB-'
    const currentNumber = parseInt(match[2], 10); // 例：1001
    const digits = match[2].length; // ゼロパディング用

    // 新しい番号を計算
    let newNumber = currentNumber + delta;

    // 下げる場合は、サーバーに問い合わせて最小値を確認
    if (delta < 0) {
      // 一時的に無効化して二重クリックを防止
      const buttons = document.querySelectorAll('button[onclick*="adjustManagementNumber"]');
      buttons.forEach(btn => btn.disabled = true);

      // サーバーに問い合わせ
      google.script.run
        .withSuccessHandler(function(minAvailableNumber) {
          buttons.forEach(btn => btn.disabled = false);

          if (typeof minAvailableNumber === 'string' && minAvailableNumber.startsWith('NG(')) {
            console.error('最小番号取得エラー:', minAvailableNumber);
            return;
          }

          // 最小使用可能番号以上に制限
          const finalNumber = Math.max(minAvailableNumber, newNumber);
          const paddedNumber = String(finalNumber).padStart(digits, '0');
          const newValue = prefix + paddedNumber;

          input.value = newValue;
          console.log(`管理番号を調整: ${currentValue} → ${newValue} (最小: ${minAvailableNumber})`);

          if (finalNumber === minAvailableNumber && newNumber < minAvailableNumber) {
            // 既に最小値に達している場合は通知
            console.log('これ以上下げられません（使用済みの番号です）');
          }
        })
        .withFailureHandler(function(error) {
          buttons.forEach(btn => btn.disabled = false);
          console.error('最小番号取得失敗:', error);
        })
        .getMinAvailableNumber(prefix.replace(/-$/, ''), digits, parseInt(match[2]));
    } else {
      // 上げる場合はそのまま適用
      newNumber = Math.max(1, newNumber);
      const paddedNumber = String(newNumber).padStart(digits, '0');
      const newValue = prefix + paddedNumber;
      input.value = newValue;
      console.log(`管理番号を調整: ${currentValue} → ${newValue}`);
    }
  }

  // 旧UI初期化（後方互換用）
  function initLegacyManagementUI() {
    const container = document.getElementById('managementNumberFields');
    if (!container) return;

    container.innerHTML = `
      <div class="row3">
        <div>
          <span class="small">頭文字</span>
          <select id="prefix1" class="tight">
            <option value="">--</option>
          </select>
        </div>
        <div>
          <span class="small">棚番号</span>
          <select id="棚番号" class="tight" disabled>
            <option value="">--</option>
          </select>
        </div>
        <div></div>
      </div>
    `;

    initPrefix1();
  }

  // ========== 旧システム（後方互換用） ==========

  // 頭文字プルダウンを初期化
  function initPrefix1() {
    const p1 = document.getElementById('prefix1');
    if (!p1) return;
    p1.innerHTML = '<option value="">--</option>';
    for (let c=65;c<=90;c++) {
      const v=String.fromCharCode(c);
      p1.insertAdjacentHTML('beforeend', `<option value="${v}">${v}</option>`);
    }
  }

  // 棚番号プルダウンを構築
  function buildShelf() {
    const p1 = document.getElementById('prefix1');
    const shelf = document.getElementById('棚番号');
    if (!p1 || !shelf) return;
    const v1 = p1.value;
    shelf.innerHTML = '<option value="">--</option>';
    if (!v1) {
      shelf.disabled = true;
      setManagementNumber('', '選択してください');
      return;
    }
    shelf.disabled = false;
    for (let c=65;c<=90;c++) {
      const v=v1+String.fromCharCode(c);
      shelf.insertAdjacentHTML('beforeend', `<option value="${v}">${v}</option>`);
    }
    shelf.value = '';
    setManagementNumber('', '選択してください');
  }

  // 棚番号選択時に管理番号を取得
  function requestNextManagementNumber() {
    const shelfSel = document.getElementById('棚番号');
    if (!shelfSel) {
      setManagementNumber('', '選択してください');
      return;
    }
    const shelf = shelfSel.value;
    if (!shelf) {
      setManagementNumber('', '選択してください');
      return;
    }
    setManagementNumber('', '採番中…');
    if (!(google && google.script && google.script.run)) {
      setManagementNumber('', '');
      return;
    }
    google.script.run.withSuccessHandler(res=>{
      if (typeof res === 'string' && res.startsWith('NG(')) {
        show(res);
        setManagementNumber('', 'エラー');
        return;
      }
      setManagementNumber(res, '');
    }).withFailureHandler(e=> {
      show(`NG(UNKNOWN): ${e && e.message ? e.message : e}`);
      setManagementNumber('', 'エラー');
    }).getNextManagementNumber(shelf);
  }

  // 管理番号フィールドに値を設定
  function setManagementNumber(val, ph) {
    const el=document.getElementById('管理番号');
    if (!el) return;
    el.value=val||'';
    el.placeholder=ph||'';

    // 管理番号が変更されたら商品名プレビューも更新
    if (typeof updateNamePreview === 'function') {
      updateNamePreview();
    }
  }

  let NAME_REST_FIELDS = ['商品属性1_値'];

  // DOM要素キャッシュ
  const elementCache = new Map();

  function _val(id) {
    if (!elementCache.has(id)) {
      elementCache.set(id, document.getElementById(id));
    }
    const el = elementCache.get(id);
    return (el && (el.value||'').toString().trim()) || '';
  }

  // キャッシュクリア機能（必要時のため）
  function clearElementCache() {
    elementCache.clear();
  }

  function _truncateByCodePoints(str, limit) {
    const a = Array.from(str);
    return (a.length > limit) ? a.slice(0, limit).join('') : str;
  }

  function adjustPreviewHeight() {
    const ta = document.getElementById('商品名プレビュー');
    if (!ta) return;
    ta.classList.remove('scroll');
    ta.style.height = 'auto';
    const sh = ta.scrollHeight;
    const max = 140;
    if (sh > max) {
      ta.style.height = max + 'px';
      ta.classList.add('scroll');
    } else {
      ta.style.height = sh + 'px';
    }
  }

  /**
   * セールスワードに形式を適用
   */
  function applySaleswordFormat(salesword) {
    if (!salesword) return '';

    // ワード別オーバーライドを確認
    let prefix = SALESWORD_FORMAT.globalPrefix;
    let suffix = SALESWORD_FORMAT.globalSuffix;

    if (SALESWORD_FORMAT.wordOverrides) {
      const override = SALESWORD_FORMAT.wordOverrides.find(o => o.word === salesword);
      if (override) {
        prefix = override.prefix;
        suffix = override.suffix;
      }
    }

    return prefix + salesword + suffix;
  }

  // ========== 商品名ブロック並び替え機能 ==========

  /**
   * 商品名ブロックのドラッグ&ドロップを初期化（Sortable.js使用）
   * タッチデバイス（スマホ）でも動作するようになりました
   */
  function initTitleBlockDragDrop() {
    const container = document.getElementById('titleBlockContainer');
    if (!container) return;

    // Sortable.jsを使用してドラッグ&ドロップを初期化
    // タッチイベントに自動対応
    Sortable.create(container, {
      animation: 150,                    // アニメーション速度（ミリ秒）
      handle: '.drag-handle',            // ⋮⋮ アイコンのみでドラッグ
      ghostClass: 'sortable-ghost',      // ドラッグ中の要素に適用されるクラス
      chosenClass: 'sortable-chosen',    // 選択中の要素に適用されるクラス
      dragClass: 'sortable-drag',        // ドラッグ中の要素に適用されるクラス
      onEnd: function() {
        // ドロップ後に並び順を保存
        saveTitleBlockOrder();
        updateNamePreview();
      }
    });
  }

  /**
   * 現在の商品名ブロックの並び順を保存
   */
  function saveTitleBlockOrder() {
    const container = document.getElementById('titleBlockContainer');
    if (!container) return;

    const blocks = container.querySelectorAll('.title-draggable-block');
    TITLE_BLOCK_ORDER = Array.from(blocks).map(block => block.dataset.blockId);
    console.log('商品名ブロックの並び順を更新:', TITLE_BLOCK_ORDER);

    // 設定マスタに保存
    if (google && google.script && google.script.run) {
      google.script.run
        .withSuccessHandler(function(result) {
          console.log('商品名ブロックの並び順を設定マスタに保存しました');
        })
        .withFailureHandler(function(error) {
          console.error('商品名ブロック並び順保存エラー:', error);
        })
        .saveTitleBlockOrder(TITLE_BLOCK_ORDER);
    }
  }

  /**
   * 保存された並び順でブロックを再配置
   */
  function applyTitleBlockOrder() {
    const container = document.getElementById('titleBlockContainer');
    if (!container || !TITLE_BLOCK_ORDER || TITLE_BLOCK_ORDER.length === 0) return;

    TITLE_BLOCK_ORDER.forEach(blockId => {
      const block = container.querySelector(`[data-block-id="${blockId}"]`);
      if (block) {
        container.appendChild(block);
      }
    });
  }

  /**
   * 商品名プレビューを更新
   * セールスワード、ブランド名、アイテム名、商品属性、管理番号を組み立てる
   * TITLE_BLOCK_ORDERの順序に従って表示
   * @throws {Error} 処理中にエラーが発生した場合
   */
  function updateNamePreview() {
    try {
      // 各ブロックの値を取得
      const kw = _val('セールスワード');
      const formattedKw = applySaleswordFormat(kw);

    // 商品名ブロック内のブランドを参照（どちらか片方でも可）
    const brandEn = _val('商品名_ブランド(英語)');
    const brandKana = _val('商品名_ブランド(カナ)');

    // チェックボックスの状態を確認
    const brandEnCheckbox = document.getElementById('商品名_ブランド(英語)_チェック');
    const brandKanaCheckbox = document.getElementById('商品名_ブランド(カナ)_チェック');
    const useBrandEn = brandEnCheckbox && brandEnCheckbox.checked && brandEn;
    const useBrandKana = brandKanaCheckbox && brandKanaCheckbox.checked && brandKana;

    // ブランド名の構築（カナの前に半角スペース）
    let brands = '';
    if (useBrandEn && useBrandKana) {
      brands = brandEn + ' ' + brandKana;
    } else if (useBrandEn) {
      brands = brandEn;
    } else if (useBrandKana) {
      brands = brandKana;
    }

    // 商品名ブロック内のアイテム名（編集可能）
    const itemNameInTitle = _val('商品名_アイテム名');
    const others = NAME_REST_FIELDS.map(_val).filter(Boolean);

    // 並び順に基づいて商品名を構築
    const parts = [];
    TITLE_BLOCK_ORDER.forEach(blockId => {
      if (blockId === 'salesword' && formattedKw) {
        parts.push(formattedKw);
      } else if (blockId === 'brand' && brands) {
        parts.push(brands);
      } else if (blockId === 'item' && itemNameInTitle) {
        // 商品名ブロック内のアイテム名を使用
        parts.push(itemNameInTitle);
      } else if (blockId === 'attribute') {
        // 商品属性のみを追加（アイテム名は含めない）
        if (others.length) parts.push(...others);
      }
    });

    let text = parts.join(' ');

    // 管理番号を商品名に追加（チェックボックスがONの場合）
    const mgmtNumberCheckbox = document.getElementById('商品名に管理番号配置');
    if (mgmtNumberCheckbox && mgmtNumberCheckbox.checked) {
      const mgmtNumber = _val('管理番号');
      if (mgmtNumber) {
        const format = _val('管理番号形式') || '【】';
        let formattedMgmtNumber = '';

        switch (format) {
          case '【】':
            formattedMgmtNumber = `【${mgmtNumber}】`;
            break;
          case '()':
            formattedMgmtNumber = `（${mgmtNumber}）`;
            break;
          case '｜':
            formattedMgmtNumber = `｜${mgmtNumber}`;
            break;
          case '-':
            formattedMgmtNumber = `- ${mgmtNumber}`;
            break;
          case 'none':
            formattedMgmtNumber = mgmtNumber;
            break;
          default:
            formattedMgmtNumber = `【${mgmtNumber}】`;
        }

        // 商品名の最後に管理番号を追加（スペース区切り）
        text = text ? `${text} ${formattedMgmtNumber}` : formattedMgmtNumber;
      }
    }

    const count = Array.from(text).length;
    const counterEl = document.getElementById('nameCounter');
    const nameCountEl = document.getElementById('nameCount');
    const nameMaxEl = document.getElementById('nameMax');
    if (nameCountEl) nameCountEl.textContent = count;
    if (nameMaxEl) nameMaxEl.textContent = NAME_LIMIT;
    if (counterEl) counterEl.classList.toggle('over', count > NAME_LIMIT);
    let saveText = text;
    if (NAME_LIMIT_MODE === 'truncate' && count > NAME_LIMIT) {
      saveText = _truncateByCodePoints(text, NAME_LIMIT);
    }
    const ta = document.getElementById('商品名プレビュー');
    if (ta) {
      ta.value = text;
      adjustPreviewHeight();
    }
      const hidden = document.getElementById('商品名(タイトル)');
      if (hidden) hidden.value = saveText;

      // 形式選択が変更された場合も設定を保存
      saveManagementNumberPlacementSettings();
    } catch (error) {
      console.error('商品名プレビュー更新エラー:', error);
      debug.error('updateNamePreview エラー:', error);
    }
  }

  // 管理番号配置設定を保存
  function saveManagementNumberPlacementSettings() {
    const titleCheckbox = document.getElementById('商品名に管理番号配置');
    const descCheckbox = document.getElementById('説明文に管理番号配置');
    const formatSelect = document.getElementById('管理番号形式');

    const settings = {
      inTitle: titleCheckbox ? titleCheckbox.checked : false,
      inDesc: descCheckbox ? descCheckbox.checked : false,
      format: formatSelect ? formatSelect.value : '【】'
    };

    try {
      localStorage.setItem('managementNumberPlacement', JSON.stringify(settings));
    } catch (e) {
      console.warn('LocalStorage保存エラー:', e);
    }
  }

  // 管理番号配置設定を復元
  function restoreManagementNumberPlacementSettings() {
    try {
      const saved = localStorage.getItem('managementNumberPlacement');
      if (!saved) return;

      const settings = JSON.parse(saved);
      const titleCheckbox = document.getElementById('商品名に管理番号配置');
      const descCheckbox = document.getElementById('説明文に管理番号配置');
      const formatSelect = document.getElementById('管理番号形式');
      const formatSelector = document.getElementById('管理番号形式選択');

      if (titleCheckbox) titleCheckbox.checked = settings.inTitle || false;
      if (descCheckbox) descCheckbox.checked = settings.inDesc || false;
      if (formatSelect) formatSelect.value = settings.format || '【】';

      // 形式選択の表示/非表示を更新
      if (formatSelector && titleCheckbox) {
        formatSelector.style.display = titleCheckbox.checked ? 'block' : 'none';
      }
    } catch (e) {
      console.warn('LocalStorage読み込みエラー:', e);
    }
  }

  // 管理番号配置オプションの表示切り替え
  function toggleManagementNumberOptions() {
    const titleCheckbox = document.getElementById('商品名に管理番号配置');
    const descCheckbox = document.getElementById('説明文に管理番号配置');
    const formatSelector = document.getElementById('管理番号形式選択');

    // 商品名チェックボックスがONの時だけ形式選択を表示
    if (formatSelector) {
      if (titleCheckbox && titleCheckbox.checked) {
        formatSelector.style.display = 'block';
      } else {
        formatSelector.style.display = 'none';
      }
    }

    // 設定の保存は「保存」ボタン押下時に行う

    // 商品名プレビューを更新
    updateNamePreview();

    // 商品の説明プレビューを更新
    if (typeof updateDescriptionFromDetail === 'function') {
      updateDescriptionFromDetail();
    }
  }

  // アイテム名表示フィールドの更新（基本情報→商品名ブロックへ自動反映）
  function updateItemNameDisplay() {
    try {
      console.log('★★★ updateItemNameDisplay() が呼ばれました');
      const basicItemName = _val('アイテム名');
      const titleItemField = document.getElementById('商品名_アイテム名');

      if (titleItemField && basicItemName) {
        titleItemField.value = basicItemName;
        updateNamePreview();
      }

      // === 中分類に応じてサイズセクションを切り替え ===
      const chuBunrui = _val('中分類(カテゴリ)');
      console.log(`★★★ 中分類を取得しました: "${chuBunrui}"`);
      updateSizeSectionDisplay(chuBunrui);
    } catch (error) {
      console.error('updateItemNameDisplay エラー:', error);
      // エラーが起きても処理を続行
    }
  }

  // ブランド表示フィールドの更新（基本情報→商品名ブロックへ自動反映）
  let updateBrandDisplayTimeout = null;
  function updateBrandDisplay() {
    // デバウンス処理: 300ms待ってから実行
    clearTimeout(updateBrandDisplayTimeout);
    updateBrandDisplayTimeout = setTimeout(() => {
      const englishName = _val('ブランド(英語)');
      const englishField = document.getElementById('商品名_ブランド(英語)');
      const kanaField = document.getElementById('商品名_ブランド(カナ)');
      const basicKanaField = document.getElementById('ブランド(カナ)');

      if (!englishField || !kanaField) return;

      if (englishName) {
        // 完全一致するブランドのみセット（途中の文字列では反応しない）
        const pairIndex = BRAND_INDEX_MAP.get(englishName);

        if (pairIndex !== undefined && BRAND_PAIRS[pairIndex]) {
          const kanaName = BRAND_PAIRS[pairIndex].kana;

          englishField.value = englishName;
          kanaField.value = kanaName;

          // 基本情報ブロックの隠しフィールドにもカナ読みを設定
          if (basicKanaField) {
            basicKanaField.value = kanaName;
            console.log(`基本情報ブランド(カナ)に設定: "${kanaName}"`);
          }

          // 商品名プレビューを更新
          updateNamePreview();
        }
      } else {
        // 空の場合はクリア
        englishField.value = '';
        kanaField.value = '';
        englishField.placeholder = '入力すると候補が表示されます';
        kanaField.placeholder = '入力すると候補が表示されます';

        // 基本情報ブロックの隠しフィールドもクリア
        if (basicKanaField) {
          basicKanaField.value = '';
        }

        // 商品名プレビューを更新
        updateNamePreview();
      }
    }, 300);
  }

  function wirePreviewWatchers() {
    const ids = new Set(['セールスワード','ブランド(英語)','アイテム名','セールスワード(カテゴリ)',
  '商品名_ブランド(英語)', '商品名_ブランド(カナ)', ...NAME_REST_FIELDS]);
    ids.forEach(id=>{
      const el = document.getElementById(id);
      if (!el) return;
      const ev = (el.tagName === 'INPUT') ? 'input' : 'change';

      // 既存のイベントリスナーを削除してから追加
      el.removeEventListener(ev, updateNamePreview);
      el.addEventListener(ev, updateNamePreview);

      // 基本情報のブランド(英語)の場合はブランド表示と商品説明も更新
      if (id === 'ブランド(英語)') {
        el.removeEventListener(ev, updateBrandDisplay);
        el.addEventListener(ev, updateBrandDisplay);
        el.removeEventListener(ev, updateDescriptionFromDetail);
        el.addEventListener(ev, updateDescriptionFromDetail);
      }
    });
  }

  function adjustDescHeight() {
    // この関数は autoResizeTextarea() に置き換えられました
    const ta = document.getElementById('商品の説明');
    if (!ta) return;
    autoResizeTextarea(ta);
  }

  function updateDesc() {
    const ta = document.getElementById('商品の説明');
    if (!ta) return;
    const text = (ta.value || '').toString();
    const count = Array.from(text).length;
    const counterEl = document.getElementById('descCounter');
    const descCountEl = document.getElementById('descCount');
    const descMaxEl = document.getElementById('descMax');
    if (descCountEl) descCountEl.textContent = count;
    if (descMaxEl) descMaxEl.textContent = DESC_LIMIT;
    if (counterEl) counterEl.classList.toggle('over', count > DESC_LIMIT);
    if (DESC_LIMIT_MODE === 'truncate' && count > DESC_LIMIT) {
      ta.value = Array.from(text).slice(0, DESC_LIMIT).join('');
    }
    adjustDescHeight();
  }

  function wireDescWatcher() {
    const ta = document.getElementById('商品の説明');
    if (!ta) return;
    ta.addEventListener('input', updateDesc);
  }

  // ブランド情報取得関数
  function getBrandInfo() {
    const englishName = _val('ブランド(英語)');
    if (!englishName) return '';

    const pairIndex = BRAND_INDEX_MAP.get(englishName);
    const kanaName = pairIndex !== undefined && BRAND_PAIRS[pairIndex] ? BRAND_PAIRS[pairIndex].kana : '';
    return `ブランド名：${englishName}（${kanaName}）\n\n`;
  }

  // サイズ情報取得関数
  function getSizeInfo() {
    // サイズ(表記)を取得（服または靴）
    const sizeHyoki = _val('サイズ(表記)_トップス') || _val('サイズ(表記)_ボトムス') || _val('サイズ(表記)_靴');

    // 靴の追加情報を取得
    const shoesOtherSize = _val('その他のサイズ表記_靴');
    const shoesUsualSize = _val('普段のサイズ_靴');
    const shoesFit = _val('フィット感_靴');

    // ラグラン判定
    const itemName = _val('アイテム名');
    const isRaglan = itemName && itemName.includes('ラグラン');
    const shoulderLabel = isRaglan ? '裄丈' : '肩幅';

    // サイズ(実寸)を取得
    const sizeValues = {
      肩幅: _val('肩幅'),
      身幅: _val('身幅'),
      袖丈: _val('袖丈'),
      着丈: _val('着丈'),
      ウエスト: _val('ウエスト'),
      ヒップ: _val('ヒップ'),
      股上: _val('股上'),
      股下: _val('股下')
    };

    // 靴または服のサイズ情報があるか確認
    const hasShoesSizeData = sizeHyoki && (_val('サイズ(表記)_靴') !== '');
    const hasClothesSizeData = sizeHyoki && (Object.values(sizeValues).some(value => value) || _val('サイズ(表記)_トップス') || _val('サイズ(表記)_ボトムス'));

    if (!sizeHyoki && !shoesOtherSize && !shoesUsualSize && !shoesFit) return '';

    let sizeText = '';

    // サイズ(表記)セクション
    if (sizeHyoki) {
      sizeText += `サイズ(表記)：${sizeHyoki}\n`;
    }

    // 靴の場合の追加情報
    if (hasShoesSizeData || shoesOtherSize || shoesUsualSize || shoesFit) {
      if (shoesOtherSize) {
        sizeText += `その他のサイズ表記：${shoesOtherSize}\n`;
      }
      if (shoesUsualSize) {
        sizeText += `普段のサイズ：${shoesUsualSize}\n`;
      }
      if (shoesFit) {
        sizeText += `フィット感：${shoesFit}\n`;
      }
      sizeText += '\n';
      return sizeText; // 靴の場合は実寸サイズを表示しない
    }

    // 服の場合のみ実寸サイズを表示
    if (sizeHyoki) {
      sizeText += '\n';
    }

    // サイズ(実寸)セクション
    const hasJissunData = Object.values(sizeValues).some(value => value);
    if (hasJissunData) {
      sizeText += '【サイズ(実寸)】\n';
      if (sizeValues.肩幅) sizeText += `${shoulderLabel}：${sizeValues.肩幅}cm\n`;
      if (sizeValues.身幅) sizeText += `身幅：${sizeValues.身幅}cm\n`;
      if (sizeValues.袖丈) sizeText += `袖丈：${sizeValues.袖丈}cm\n`;
      if (sizeValues.着丈) sizeText += `着丈：${sizeValues.着丈}cm\n`;
      if (sizeValues.ウエスト) sizeText += `ウエスト：${sizeValues.ウエスト}cm\n`;
      if (sizeValues.ヒップ) sizeText += `ヒップ：${sizeValues.ヒップ}cm\n`;
      if (sizeValues.股上) sizeText += `股上：${sizeValues.股上}cm\n`;
      if (sizeValues.股下) sizeText += `股下：${sizeValues.股下}cm\n`;
      sizeText += '\n';
    }

    return sizeText;
  }

  // 素材情報取得関数
  function getMaterialInfo() {
    let materialText = '';
    const items = document.querySelectorAll('.material-item');

    items.forEach((item, i) => {
      const index = i + 1;
      const location = _val(`素材${index}_箇所`);
      const type1 = _val(`素材${index}_種類1`);
      const percent1 = _val(`素材${index}_％1`);
      const type2 = _val(`素材${index}_種類2`);
      const percent2 = _val(`素材${index}_％2`);

      if (location && type1) {
        materialText += `${location}: ${type1}`;
        if (percent1) materialText += ` ${percent1}%`;
        if (type2) {
          materialText += `, ${type2}`;
          if (percent2) materialText += ` ${percent2}%`;
        }
        materialText += '\n';
      }
    });

    if (materialText) {
      materialText = '【素材】\n' + materialText + '\n';
    }

    return materialText;
  }

  function getColorInfo() {
    const items = document.querySelectorAll('.color-item');
    const colors = [];

    items.forEach((item, i) => {
      const index = i + 1;
      const colorValue = _val(`カラー${index}`);
      if (colorValue) {
        colors.push(colorValue);
      }
    });

    if (colors.length > 0) {
      return 'カラー(詳細)：' + colors.join('、') + '\n\n';
    }

    return '';
  }

  /**
   * 配置順序に従って商品説明を組み立てる
   * @param {Object} elements - 各要素のテキスト（brand, color, size, material, condition, ai, management, discount, hashtag）
   * @param {HTMLTextAreaElement} descTextarea - 説明文を表示するテキストエリア
   */
  function buildDescriptionByOrder(elements, descTextarea) {
    console.log('buildDescriptionByOrder 関数が呼び出されました');

    // 1. HTML要素の実際の順序を取得（最優先）
    const actualBlocksOrder = getDescriptionBlocksOrder();
    console.log('実際のブロック順序:', actualBlocksOrder);

    // 2. ブロックタイプとelements[id]のマッピング
    const blockTypeToElementId = {
      'brandName': 'brand',
      'size': 'size',
      'color': 'color',
      'condition': 'condition',
      'material': 'material',
      'aiGeneration': 'aiGeneration',
      'discount': 'discount',
      'hashtag': 'hashtag'
    };

    // 3. 実際の順序に基づいて配置順序を構築
    let order = [];
    if (actualBlocksOrder.length > 0) {
      order = actualBlocksOrder.map(blockType => ({
        id: blockTypeToElementId[blockType] || blockType,
        enabled: true
      }));
      console.log('実際のブロック順序から配置順序を生成:', order);
    } else {
      // フォールバック: デフォルト順序
      order = [
        { id: 'brand', enabled: true },
        { id: 'size', enabled: true },
        { id: 'color', enabled: true },
        { id: 'condition', enabled: true },
        { id: 'material', enabled: true },
        { id: 'ai', enabled: true },
        { id: 'discount', enabled: true },
        { id: 'hashtag', enabled: true }
      ];
      console.log('デフォルト順序を使用');
    }

    // 3. 配置順序に従って説明文を組み立て
    const parts = [];

    for (const item of order) {
      // 無効化されている要素はスキップ
      if (item.enabled === false) {
        console.log(`要素 ${item.id} は無効化されているためスキップ`);
        continue;
      }

      // 要素の内容を取得
      const content = elements[item.id];
      if (content && content.trim()) {
        parts.push(content.trim());
        console.log(`要素 ${item.id} を追加`);
      } else {
        console.log(`要素 ${item.id} は空のためスキップ`);
      }
    }

    // 4. 全要素を結合（2行の空行で区切る）
    const finalText = parts.join('\n\n');
    descTextarea.value = finalText;

    console.log('商品説明を配置順序に従って生成しました:', finalText.length, '文字');

    // 5. UIを更新
    if (typeof updateDesc === 'function') {
      updateDesc();
    }
    autoResizeTextarea(descTextarea);
  }

  // ================= 画像アップロード機能 =================

  // アップロードされた画像を保存する配列
  let uploadedImages = [];

  /**
   * 画像アップロード処理
   * @param {Event} event - ファイル選択イベント
   */
  function handleImageUpload(event) {
    const files = event.target.files;

    if (!files || files.length === 0) {
      return;
    }

    // 既存の画像数と新規画像数の合計が3を超える場合は警告
    if (uploadedImages.length + files.length > 3) {
      alert('画像は最大3枚までアップロードできます');
      return;
    }

    // 各ファイルをBase64に変換
    Array.from(files).forEach((file, index) => {
      // ファイルサイズチェック（10MB制限）
      if (file.size > 10 * 1024 * 1024) {
        alert(`${file.name}のサイズが大きすぎます（最大10MB）`);
        return;
      }

      // 画像ファイルかチェック
      if (!file.type.startsWith('image/')) {
        alert(`${file.name}は画像ファイルではありません`);
        return;
      }

      const reader = new FileReader();

      reader.onload = function(e) {
        const base64Data = e.target.result;

        uploadedImages.push({
          name: file.name,
          data: base64Data,
          mimeType: file.type
        });

        // プレビューを更新
        displayImagePreviews();

        debug.log(`画像をアップロードしました: ${file.name}`);
      };

      reader.onerror = function(error) {
        console.error('画像の読み込みに失敗しました:', error);
        alert(`${file.name}の読み込みに失敗しました`);
      };

      reader.readAsDataURL(file);
    });
  }

  /**
   * 画像プレビューを表示
   */
  function displayImagePreviews() {
    const container = document.getElementById('imagePreviewContainer');
    const list = document.getElementById('imagePreviewList');
    const count = document.getElementById('imageCount');

    if (!container || !list || !count) {
      console.error('プレビュー要素が見つかりません');
      return;
    }

    // 画像がない場合は非表示
    if (uploadedImages.length === 0) {
      container.style.display = 'none';
      return;
    }

    // 画像がある場合は表示
    container.style.display = 'block';
    count.textContent = uploadedImages.length;

    // プレビューリストをクリア
    list.innerHTML = '';

    // 各画像のプレビューを作成
    uploadedImages.forEach((image, index) => {
      const previewItem = document.createElement('div');
      previewItem.style.cssText = 'position: relative; aspect-ratio: 1; border-radius: 8px; overflow: hidden; border: 2px solid #e5e7eb;';

      previewItem.innerHTML = `
        <img src="${image.data}" alt="${image.name}" style="width: 100%; height: 100%; object-fit: cover;">
        <button
          type="button"
          onclick="removeImage(${index})"
          style="position: absolute; top: 4px; right: 4px; background: rgba(239, 68, 68, 0.9); color: white; border: none; border-radius: 50%; width: 24px; height: 24px; font-size: 16px; cursor: pointer; display: flex; align-items: center; justify-content: center; padding: 0;"
          title="削除"
        >×</button>
      `;

      list.appendChild(previewItem);
    });
  }

  /**
   * 画像を削除
   * @param {number} index - 削除する画像のインデックス
   */
  function removeImage(index) {
    uploadedImages.splice(index, 1);
    displayImagePreviews();
    debug.log(`画像を削除しました (index: ${index})`);
  }

  /**
   * アップロードされた画像を取得
   * @returns {Array} Base64画像データの配列
   */
  function getUploadedImages() {
    return uploadedImages.map(img => ({
      data: img.data.split(',')[1], // Base64部分のみ（data:image/png;base64,を除く）
      mimeType: img.mimeType
    }));
  }

  // ================= AI生成機能 =================

  /**
   * AI生成ボタンクリック時の処理
   * 商品情報を収集してGemini APIで説明文を生成
   */
  function generateAiDescription() {
    try {
      debug.log('AI説明文生成を開始します');

      // ボタンの状態を変更（ローディング表示）
      const aiGenBtn = document.getElementById('aiGenBtn');
      if (!aiGenBtn) {
        console.error('AI生成ボタンが見つかりません');
        return;
      }

      // 元のテキストを保存
      const originalText = aiGenBtn.innerHTML;

      // ローディング状態に変更
      aiGenBtn.disabled = true;
      aiGenBtn.innerHTML = '⏳ 生成中...';
      aiGenBtn.style.opacity = '0.6';
      aiGenBtn.style.cursor = 'wait';

      // 商品情報を収集
      const productInfo = collectProductInfo();

      // 画像データを取得
      const images = getUploadedImages();

      debug.log('収集した商品情報:', productInfo);
      debug.log('アップロードされた画像数:', images.length);

      // バリデーション
      if (!productInfo.brandName || !productInfo.itemName) {
        alert('❌ ブランド名とアイテム名を入力してください。');
        resetAiButton(aiGenBtn, originalText);
        return;
      }

      // サーバー側のAPI呼び出し
      google.script.run
        .withSuccessHandler(function(generatedText) {
          debug.log('AI生成成功:', generatedText);

          // AI生成文をグローバル変数に保存
          AI_GENERATED_TEXT = generatedText;

          // プレビューを更新
          updateDescriptionFromDetail();

          // 成功メッセージ
          alert(`✅ AI説明文を生成しました！

商品の説明プレビューを確認して、必要に応じて直接編集してください。

⚠️ 注意事項
• 品番から取得した情報は、Google検索結果の品質に依存します
• 画像から取得した情報は、AIの判断に基づいています
• 必ず内容をご確認の上、誤りがあれば修正してください`);

          // ボタンを元に戻す
          resetAiButton(aiGenBtn, originalText);

          // 画像データはクリアしない（保存時に画像URLを記録するため）
          debug.log('AI生成成功。画像データは保存時まで保持します。');
        })
        .withFailureHandler(function(error) {
          console.error('AI生成エラー:', error);

          // エラーメッセージの表示
          let errorMsg = 'AI説明文の生成に失敗しました。\n\n';

          if (error.message && error.message.includes('NG(CONFIG)')) {
            errorMsg += 'APIキーが設定されていません。\n\n';
            errorMsg += '【設定手順】\n';
            errorMsg += '1. Google Apps Scriptエディタを開く\n';
            errorMsg += '2. ⚙️ プロジェクトの設定を開く\n';
            errorMsg += '3. スクリプト プロパティに追加:\n';
            errorMsg += '   プロパティ: GEMINI_API_KEY\n';
            errorMsg += '   値: あなたのAPIキー';
          } else if (error.message && error.message.includes('NG(API)')) {
            errorMsg += 'API呼び出しに失敗しました。\n';
            errorMsg += 'しばらく時間をおいて再度お試しください。\n\n';
            errorMsg += `エラー詳細: ${error.message}`;
          } else {
            errorMsg += `エラー詳細: ${error.message || 'Unknown error'}`;
          }

          alert('❌ ' + errorMsg);

          // ボタンを元に戻す
          resetAiButton(aiGenBtn, originalText);
        })
        .generateProductDescription(productInfo, images);

    } catch (error) {
      console.error('AI生成処理エラー:', error);
      alert('❌ エラーが発生しました: ' + error.message);

      // ボタンを元に戻す
      const aiGenBtn = document.getElementById('aiGenBtn');
      if (aiGenBtn) {
        resetAiButton(aiGenBtn, '✨ AI生成');
      }
    }
  }

  /**
   * 商品情報を収集（AI生成用）
   * @returns {Object} 商品情報オブジェクト
   */
  function collectProductInfo() {
    const productInfo = {};

    // ブランド名（基本情報ブロックから優先取得）
    productInfo.brandName = _val('ブランド(英語)') || _val('商品名_ブランド(英語)') || '';
    productInfo.brandKana = _val('ブランド(カナ)') || _val('商品名_ブランド(カナ)') || '';

    // アイテム名（基本情報ブロックから優先取得、なければ商品名ブロック）
    productInfo.itemName = _val('アイテム名') || _val('商品名_アイテム名') || '';

    // カテゴリ（階層情報を統合）
    const categories = [];
    const daiCategory = _val('大分類(カテゴリ)');
    const chuCategory = _val('中分類(カテゴリ)');
    const shoCategory = _val('小分類(カテゴリ)');
    if (daiCategory) categories.push(daiCategory);
    if (chuCategory) categories.push(chuCategory);
    if (shoCategory) categories.push(shoCategory);
    productInfo.category = categories.join(' > ');

    // サイズ
    productInfo.size = _val('サイズ(表記)_トップス') || _val('サイズ(表記)_ボトムス') || _val('サイズ') || '';

    // 商品の状態
    productInfo.condition = _val('商品の状態') || '';

    // 素材情報を収集
    const materials = [];
    for (let i = 1; i <= 10; i++) {
      const location = _val(`素材${i}_箇所`);
      const type1 = _val(`素材${i}_種類1`);
      const percent1 = _val(`素材${i}_％1`);

      if (location || type1) {
        let materialStr = '';
        if (location) materialStr += location + ': ';
        if (type1) {
          materialStr += type1;
          if (percent1) materialStr += ` ${percent1}%`;
        }
        materials.push(materialStr);
      }
    }
    productInfo.material = materials.join(', ');

    // カラー情報を収集（selectドロップダウンから）
    const colors = [];
    for (let i = 1; i <= 10; i++) {
      const colorValue = _val(`カラー${i}`);
      if (colorValue) {
        colors.push(colorValue);
        debug.log(`カラー${i}: ${colorValue}`);
      }
    }
    productInfo.color = colors.join(', ');
    debug.log(`収集したカラー情報: "${productInfo.color}"`);

    // 商品属性を収集（商品名ブロックから）
    const attributes = [];
    for (let i = 1; i <= 10; i++) {
      const attrValue = _val(`商品属性${i}`);
      if (attrValue) {
        attributes.push(attrValue);
      }
    }

    // AI生成用 追加属性を収集（商品の説明ブロックから）
    // キャッシュを使わず直接取得（最新の値を確実に取得するため）
    const aiAttributesElement = document.getElementById('AI用商品属性');
    const aiAttributesText = aiAttributesElement ? aiAttributesElement.value.trim() : '';

    debug.log(`AI用商品属性の値: "${aiAttributesText}"`);

    if (aiAttributesText) {
      // カンマ区切りで分割して追加
      const aiAttributes = aiAttributesText.split(',').map(attr => attr.trim()).filter(attr => attr);
      attributes.push(...aiAttributes);
      debug.log(`AI用商品属性を追加しました: ${aiAttributes.join(', ')}`);
    }

    productInfo.attributes = attributes.join(', ');
    debug.log(`最終的なattributes: "${productInfo.attributes}"`);

    // 品番・型番を収集（Google Search Grounding用）
    productInfo.modelNumber = _val('品番型番') || '';

    return productInfo;
  }

  /**
   * AI生成ボタンを元の状態に戻す
   * @param {HTMLElement} button - ボタン要素
   * @param {string} originalText - 元のテキスト
   */
  function resetAiButton(button, originalText) {
    if (!button) return;

    button.disabled = false;
    button.innerHTML = originalText;
    button.style.opacity = '1';
    button.style.cursor = 'pointer';
  }

  // ================= 商品の説明プレビュー =================

  /**
   * 商品の説明プレビューを更新
   * ブランド、カラー、サイズ、素材、商品状態、管理番号、割引情報、ハッシュタグを組み立てる
   * @throws {Error} 要素が見つからない場合や処理中にエラーが発生した場合
   */
  function updateDescriptionFromDetail() {
    try {
        console.log('updateDescriptionFromDetail 関数が呼び出されました');
        const detailInput = document.getElementById('商品状態詳細');
        const descTextarea = document.getElementById('商品の説明');
        if (!detailInput || !descTextarea) {
          console.error('要素が見つかりません', { detailInput, descTextarea });
          return;
        }

        // ハッシュタグチェックボックスのプレビューを更新
        updateHashtagCheckboxPreviews();

        // ブランド情報を取得
        const brandText = getBrandInfo();

        // カラー情報を取得
        const colorText = getColorInfo();

        // サイズ情報を取得
        const sizeText = getSizeInfo();

          // 素材情報を収集
          const materialText = getMaterialInfo();

          // 商品の状態を取得（基本情報ブロックから）
          const conditionSelect = document.getElementById('商品の状態');
          const conditionValue = conditionSelect ? (conditionSelect.value || '').trim() : '';
          let conditionSection = '';
          if (conditionValue) {
            conditionSection = `商品の状態：${conditionValue}\n\n`;
          }

          // 商品状態詳細を取得
          const detailText = (detailInput.value || '').trim();
          let detailSection = '';
          if (detailText) {
            detailSection = `商品状態(詳細)：\n${detailText}\n\n`;
          }

          // AI生成文を取得
          let aiGenerationSection = '';
          if (AI_GENERATED_TEXT) {
            aiGenerationSection = `${AI_GENERATED_TEXT}\n\n`;
          }

        // ハッシュタグ生成
          const hashtags = generateHashtags();
          const hashtagText = hashtags.join('\n');

          // 管理番号セクション（説明文に配置がONの場合）
          let managementNumberSection = '';
          const mgmtDescCheckbox = document.getElementById('説明文に管理番号配置');
          if (mgmtDescCheckbox && mgmtDescCheckbox.checked) {
            const mgmtNumber = _val('管理番号');
            if (mgmtNumber) {
              managementNumberSection = `管理番号：${mgmtNumber}\n\n`;
            }
          }

          // 割引案内テキスト（設定シート対応版）
          const discountInfo = generateDiscountInfo();

          // 配置順序を取得して説明文を組み立て
          buildDescriptionByOrder({
            brand: brandText,
            size: sizeText,
            color: colorText,
            condition: detailSection,
            material: materialText,
            aiGeneration: aiGenerationSection,
            discount: discountInfo,
            hashtag: hashtagText
          }, descTextarea);
    } catch (error) {
      console.error('商品の説明更新エラー:', error);
      debug.error('updateDescriptionFromDetail エラー:', error);
    }
  }

  function setupDetailEventListener() {
    console.log('setupDetailEventListener 関数が呼び出されました');
    const detailInput = document.getElementById('商品状態詳細');
    if (detailInput) {
      // 既存のイベントリスナーを削除
      detailInput.removeEventListener('input', updateDescriptionFromDetail);
      // 新しいイベントリスナーを追加
      detailInput.addEventListener('input', updateDescriptionFromDetail);
      console.log('商品状態(詳細)イベントリスナー設定完了');
      // テスト用: 初回実行
      updateDescriptionFromDetail();
    } else {
      console.error('商品状態詳細の要素が見つかりません');
    }

    // 靴のサイズ関連項目にもイベントリスナーを追加
    const shoesFields = [
      'サイズ(表記)_靴',
      'その他のサイズ表記_靴',
      '普段のサイズ_靴',
      'フィット感_靴'
    ];

    shoesFields.forEach(fieldId => {
      const element = document.getElementById(fieldId);
      if (element) {
        const eventType = element.tagName === 'SELECT' ? 'change' : 'input';
        element.removeEventListener(eventType, updateDescriptionFromDetail);
        element.addEventListener(eventType, updateDescriptionFromDetail);
        console.log(`${fieldId}のイベントリスナー設定完了`);
      }
    });
  }

  // ================= 新セールスワードシステム =================
  function initializeSalesWords() {
    console.log('=== セールスワード初期化開始 ===');
    if (!(google && google.script && google.script.run)) {
      console.log('google.script.run が利用できません');
      setupFallbackSalesWords();
      return;
    }

    // セールスワード専用データ取得と設定マスタからの「よく使う」読み込みを並行実行
    let salesWordData = null;
    let favoriteSalesWords = [];
    // defaultSalesword はグローバル変数として宣言済み（190行目）

    google.script.run
      .withSuccessHandler(function(data) {
        console.log('セールスワードデータ取得成功:', data);
        salesWordData = data;
        checkAndSetup();
      })
      .withFailureHandler(function(error) {
        console.error('セールスワードデータ取得エラー:', error);
        setupFallbackSalesWords();
      })
      .getSalesWordData();

    google.script.run
      .withSuccessHandler(function(config) {
        if (config && config.よく使うセールスワード) {
          // 新しい構造（よく使う + 表示形式 + デフォルト）に対応
          if (typeof config.よく使うセールスワード === 'object' && config.よく使うセールスワード.よく使う) {
            favoriteSalesWords = config.よく使うセールスワード.よく使う || [];
            // 表示形式設定を読み込み
            if (config.よく使うセールスワード.表示形式) {
              SALESWORD_FORMAT = config.よく使うセールスワード.表示形式;
              console.log('セールスワード表示形式取得成功:', SALESWORD_FORMAT);
            }
            // デフォルトセールスワード設定を読み込み
            if (config.よく使うセールスワード.デフォルト) {
              defaultSalesword = config.よく使うセールスワード.デフォルト;
              console.log('デフォルトセールスワード取得成功:', defaultSalesword);
            }
          } else {
            // 旧形式（配列のみ）に対応
            favoriteSalesWords = config.よく使うセールスワード;
          }
          console.log('よく使うセールスワード取得成功:', favoriteSalesWords);
        }
        checkAndSetup();
      })
      .withFailureHandler(function(error) {
        console.error('よく使うセールスワード取得エラー:', error);
        checkAndSetup();
      })
      .loadConfigMaster();

    function checkAndSetup() {
      if (salesWordData !== null) {
        SALESWORD_DATA = salesWordData;

        // 「よく使う」カテゴリを追加
        if (favoriteSalesWords.length > 0) {
          SALESWORD_DATA.wordsByCategory['よく使う'] = favoriteSalesWords;
        }

        setupCategoryDropdown();

        // デフォルトセールスワードを適用
        applyDefaultSalesword(defaultSalesword);

        console.log('セールスワード初期化完了');
      }
    }
  }

  function setupCategoryDropdown() {
    const categorySelect = document.getElementById('セールスワード(カテゴリ)');
    if (!categorySelect) {
      console.log('セールスワード(カテゴリ)要素が見つかりません');
      return;
    }
    // プルダウンをクリア
    categorySelect.innerHTML = '<option value="">-- カテゴリを選択 --</option>';

    // 「よく使う」カテゴリを先頭に追加
    if (SALESWORD_DATA.wordsByCategory['よく使う']) {
      const option = document.createElement('option');
      option.value = 'よく使う';
      option.textContent = '⭐ よく使う';
      categorySelect.appendChild(option);
    }

    // その他のカテゴリオプションを追加
    SALESWORD_DATA.categories.forEach(category => {
      const option = document.createElement('option');
      option.value = category;
      option.textContent = category;
      categorySelect.appendChild(option);
    });

    const totalCategories = SALESWORD_DATA.categories.length + (SALESWORD_DATA.wordsByCategory['よく使う'] ? 1 : 0);
    console.log(`カテゴリプルダウン設定完了: ${totalCategories}件`);
    // キーワードプルダウンをリセット
    resetKeywordDropdown();
  }

  function resetKeywordDropdown() {
    const keywordSelect = document.getElementById('セールスワード');
    if (!keywordSelect) {
      console.log('セールスワード要素が見つかりません');
      return;
    }
    keywordSelect.innerHTML = '<option value="">-- キーワードを選択 --</option>';
    keywordSelect.disabled = true;
  }

  function onSalesWordCategoryChanged() {
    const categorySelect = document.getElementById('セールスワード(カテゴリ)');
    const keywordSelect = document.getElementById('セールスワード');
    if (!categorySelect || !keywordSelect) {
      console.log('セールスワード要素が見つかりません');
      updateNamePreview();
      return;
    }
    const selectedCategory = categorySelect.value.trim();
    if (!selectedCategory) {
      resetKeywordDropdown();
      updateNamePreview();
      return;
    }
    console.log('カテゴリ選択:', selectedCategory);
    // 選択されたカテゴリのキーワードを取得
    const categoryWords = SALESWORD_DATA.wordsByCategory[selectedCategory] || [];
    // 重複を排除
    const uniqueWords = [...new Set(categoryWords)];
    // キーワードプルダウンを更新
    keywordSelect.innerHTML = '<option value="">-- キーワードを選択 --</option>';
    uniqueWords.forEach(word => {
      const option = document.createElement('option');
      option.value = word;
      // 表示は元の値のまま（形式は適用しない）
      option.textContent = word;
      keywordSelect.appendChild(option);
    });
    keywordSelect.disabled = categoryWords.length === 0;
    console.log(`キーワード設定完了: ${categoryWords.length}件`);
    updateNamePreview();
  }

  function setupFallbackSalesWords() {
    console.log('フォールバック用セールスワード設定');
    const fallbackCategories = [
      '価格・セール', '希少性・在庫状況', '状態・コンディション',
      '取引・配送方法', '商品タイプ・ジャンル'
    ];
    const fallbackWords = {
      '価格・セール': ['【セール】', '【特価】', '【値下げ】'],
      '希少性・在庫状況': ['【レア】', '【限定】', '【1点もの】'],
      '状態・コンディション': ['【美品】', '【新品同様】', '【良品】'],
      '取引・配送方法': ['【匿名配送】', '【送料無料】'],
      '商品タイプ・ジャンル': ['【古着】', '【ヴィンテージ】']
    };
    SALESWORD_DATA = {
      categories: fallbackCategories,
      wordsByCategory: fallbackWords,
      allWords: Object.values(fallbackWords).flat()
    };
    setupCategoryDropdown();
  }

  function setupSalesWordEventListeners() {
    const categorySelect = document.getElementById('セールスワード(カテゴリ)');
    if (categorySelect) {
      // 既存のイベントリスナーを削除
      categorySelect.removeEventListener('change', onSalesWordCategoryChanged);
      // 新しいイベントリスナーを追加
      categorySelect.addEventListener('change', onSalesWordCategoryChanged);
      console.log('セールスワードイベントリスナー設定完了');
    }
  }

  /**
   * デフォルトセールスワードを適用
   */
  function applyDefaultSalesword(defaultConfig) {
    if (!defaultConfig || !defaultConfig.カテゴリ || !defaultConfig.セールスワード) {
      console.log('デフォルトセールスワード設定がありません');
      return;
    }

    const categorySelect = document.getElementById('セールスワード(カテゴリ)');
    const saleswordSelect = document.getElementById('セールスワード');

    if (!categorySelect || !saleswordSelect) {
      console.log('セールスワードの要素が見つかりません');
      return;
    }

    // カテゴリを設定
    categorySelect.value = defaultConfig.カテゴリ;
    console.log('デフォルトカテゴリを設定:', defaultConfig.カテゴリ);

    // カテゴリ変更イベントをトリガー（セールスワードプルダウンを更新）
    onSalesWordCategoryChanged();

    // セールスワードを設定（プルダウン更新後に設定）
    setTimeout(() => {
      saleswordSelect.value = defaultConfig.セールスワード;
      console.log('デフォルトセールスワードを設定:', defaultConfig.セールスワード);

      // 商品名プレビューを更新
      if (typeof updateNamePreview === 'function') {
        updateNamePreview();
      }
    }, 100);
  }

  // ================= カテゴリ階層 =================
  function filterByCategory(rows) {
    const l1 = (document.getElementById('大分類(カテゴリ)')?.value||'').trim();
    const l2 = (document.getElementById('中分類(カテゴリ)')?.value||'').trim();
    const l3 = (document.getElementById('小分類(カテゴリ)')?.value||'').trim();
    const l4 = (document.getElementById('細分類(カテゴリ)')?.value||'').trim();
    const l5 = (document.getElementById('細分類2')?.value||'').trim();
    let r = rows.slice();
    if (l1) r = r.filter(x=> x.大分類 === l1);
    if (l2) r = r.filter(x=> x.中分類 === l2);
    if (l3) r = r.filter(x=> x.小分類 === l3);
    if (l4) r = r.filter(x=> x.細分類 === l4);
    if (l5) r = r.filter(x=> x.細分類2 === l5);
    return r;
  }

  function refreshItems() {
    const rows = filterByCategory(CAT_ROWS);
    fillSelectSafe(document.getElementById('アイテム名'), uniqKeepOrder(rows.map(r=>r.アイテム名)));
    updateItemNameDisplay();
    updateNamePreview();
  }

  /**
   * 中分類に応じてサイズプルダウンの選択肢を切り替える
   * @param {string} chuBunrui - 中分類の値
   */
  function updateSizeOptions(chuBunrui) {
    try {
      debug.log(`updateSizeOptions() が呼ばれました。中分類: "${chuBunrui}"`);
      const sizeSelect = document.getElementById('サイズ');
      if (!sizeSelect) {
        debug.log('サイズプルダウンが見つかりません');
        return;
      }

      const currentValue = sizeSelect.value; // 現在の選択値を保持

      // 中分類が「靴」の場合は靴用サイズ、それ以外は服用サイズ
      if (chuBunrui === '靴') {
        // 大分類でメンズ/レディースを判定
        const daiBunrui = _val('大分類(カテゴリ)');
        const shoeSizes = [];

        if (daiBunrui === 'メンズ') {
          // メンズ: 23.5cm以下、24cm～30.5cm、31cm以上
          shoeSizes.push('23.5cm以下');
          for (let size = 24.0; size <= 30.5; size += 0.5) {
            shoeSizes.push(size.toFixed(1) + 'cm');
          }
          shoeSizes.push('31cm以上');
        } else if (daiBunrui === 'レディース') {
          // レディース: 20cm以下、20.5cm～27cm、27.5cm以上
          shoeSizes.push('20cm以下');
          for (let size = 20.5; size <= 27.0; size += 0.5) {
            shoeSizes.push(size.toFixed(1) + 'cm');
          }
          shoeSizes.push('27.5cm以上');
        } else {
          // その他（キッズなど）: デフォルト
          for (let size = 22.0; size <= 30.0; size += 0.5) {
            shoeSizes.push(size.toFixed(1) + 'cm');
          }
        }

        fillSelectSafe(sizeSelect, shoeSizes);
        debug.log(`サイズプルダウンを靴用サイズに切り替えました（${daiBunrui}）`);
      } else {
        // 服用サイズ: マスターデータから取得（エラー時は何もしない）
        try {
          const sizeOptions = MASTER_OPTIONS && MASTER_OPTIONS['サイズ'] ? MASTER_OPTIONS['サイズ'] : [];
          if (sizeOptions.length > 0) {
            fillSelectSafe(sizeSelect, sizeOptions);
            debug.log('サイズプルダウンを服用サイズに切り替えました');
          } else {
            debug.log('マスターデータに服用サイズが見つかりません');
          }
        } catch (e) {
          debug.log('マスターデータからサイズ取得エラー:', e);
          // エラー時は何もしない（既存の選択肢を維持）
        }
      }

      // 以前の選択値が新しい選択肢に存在する場合は復元
      if (currentValue) {
        const options = Array.from(sizeSelect.options).map(opt => opt.value);
        if (options.includes(currentValue)) {
          sizeSelect.value = currentValue;
        }
      }
    } catch (error) {
      console.error('updateSizeOptions エラー:', error);
      // エラーが起きても処理を続行
    }
  }

  /**
   * 基本情報のサイズを商品の説明ブロックに同期
   */
  function syncBasicSizeToDescription() {
    try {
      const chuBunrui = _val('中分類(カテゴリ)');
      const basicSize = _val('サイズ');

      if (chuBunrui === '靴' && basicSize) {
        const shoesSizeSelect = document.getElementById('サイズ(表記)_靴');
        if (shoesSizeSelect) {
          shoesSizeSelect.value = basicSize;
          debug.log(`基本情報のサイズ(${basicSize})を商品の説明ブロック（靴）に反映しました`);
          // 説明文プレビューを更新
          updateDescriptionFromDetail();
        }
      }
    } catch (error) {
      console.error('syncBasicSizeToDescription エラー:', error);
    }
  }

  /**
   * 中分類に応じて商品の説明ブロックのサイズセクション表示を切り替える
   * @param {string} chuBunrui - 中分類の値
   */
  function updateSizeSectionDisplay(chuBunrui) {
    try {
      console.log(`★★★ updateSizeSectionDisplay() が呼ばれました。中分類: "${chuBunrui}"`);
      const sizeSection = document.getElementById('sizeSection');
      const topsSize = document.getElementById('topsSize');
      const bottomsSize = document.getElementById('bottomsSize');
      const shoesSize = document.getElementById('shoesSize');
      const sizeIconDisplay = document.getElementById('sizeIconDisplay');
      const sizeLabelDisplay = document.getElementById('sizeLabelDisplay');

      console.log('★★★ 要素チェック:', {sizeSection: !!sizeSection, topsSize: !!topsSize, bottomsSize: !!bottomsSize, shoesSize: !!shoesSize});

      if (!sizeSection || !topsSize || !bottomsSize || !shoesSize) {
        console.log('★★★ サイズセクションの要素が見つかりません');
        return;
      }

      // 全て非表示にする
      topsSize.style.display = 'none';
      bottomsSize.style.display = 'none';
      shoesSize.style.display = 'none';

      if (chuBunrui === '靴') {
        // 靴の場合
        console.log('★★★ 靴モード: displayを設定する前 - sizeSection.style.display:', sizeSection.style.display);
        sizeSection.style.display = 'block';

        // 折りたたみコンテンツも表示し、ボタンの状態も更新する
        const sectionContent = sizeSection.querySelector('.section-content');
        const collapseBtn = sizeSection.querySelector('.collapse-btn');
        if (sectionContent) {
          sectionContent.style.display = 'block';
          if (collapseBtn) {
            collapseBtn.textContent = '▼';
          }
          console.log('★★★ section-content とボタンを表示状態にしました');
        }

        shoesSize.style.display = 'block';
        console.log('★★★ 靴モード: displayを設定した後 - sizeSection.style.display:', sizeSection.style.display);
        console.log('★★★ 靴モード: displayを設定した後 - shoesSize.style.display:', shoesSize.style.display);

        // 要素の詳細情報をログ出力
        const rect = sizeSection.getBoundingClientRect();
        console.log('★★★ sizeSection の位置とサイズ:', {
          top: rect.top,
          left: rect.left,
          width: rect.width,
          height: rect.height,
          visible: rect.width > 0 && rect.height > 0
        });
        console.log('★★★ sizeSection の親要素:', sizeSection.parentElement ? sizeSection.parentElement.tagName : 'なし');
        console.log('★★★ sizeSection の親要素の display:', sizeSection.parentElement ? window.getComputedStyle(sizeSection.parentElement).display : 'なし');

        if (sizeIconDisplay) sizeIconDisplay.textContent = '👟';
        if (sizeLabelDisplay) sizeLabelDisplay.textContent = 'サイズ（靴）';

        // 靴用サイズ選択肢を生成
        const shoesSizeSelect = document.getElementById('サイズ(表記)_靴');
        if (shoesSizeSelect) {
          const shoeSizes = [];
          for (let size = 22.0; size <= 30.0; size += 0.5) {
            shoeSizes.push(size.toFixed(1) + 'cm');
          }
          fillSelectSafe(shoesSizeSelect, shoeSizes);

          // 基本情報のサイズを靴用サイズ(表記)に同期
          const basicSize = _val('サイズ');
          if (basicSize) {
            shoesSizeSelect.value = basicSize;
            console.log(`★★★ 基本情報のサイズ(${basicSize})を反映しました`);
          }
        }
        console.log('★★★ サイズセクションを靴用に切り替えました');
      } else {
        // 服の場合（既存の処理）
        sizeSection.style.display = 'none'; // 初期状態は非表示
        console.log('★★★ サイズセクションを非表示にしました（アイテム名選択後に表示されます）');
      }
    } catch (error) {
      console.error('updateSizeSectionDisplay エラー:', error);
      // エラーが起きても処理を続行
    }
  }

  function onL1Changed() {
    resetSelect('中分類(カテゴリ)');
    resetSelect('小分類(カテゴリ)');
    resetSelect('細分類(カテゴリ)');
    resetSelect('細分類2');
    resetSelect('アイテム名', false);
    // 細分類行を非表示
    const saibunruiRow = document.getElementById('saibunruiRow');
    if (saibunruiRow) saibunruiRow.style.display = 'none';

    const l1 = (document.getElementById('大分類(カテゴリ)')?.value||'').trim();
    if (l1) {
      const mids = uniqKeepOrder(CAT_ROWS.filter(r=>r.大分類===l1).map(r=>r.中分類));
      fillSelectSafe(document.getElementById('中分類(カテゴリ)'), mids);
    }
    refreshItems();
  }

  function onL2Changed() {
    debug.log('onL2Changed() が呼ばれました');
    resetSelect('小分類(カテゴリ)');
    resetSelect('細分類(カテゴリ)');
    resetSelect('細分類2');
    resetSelect('アイテム名', false);
    // 細分類行を非表示
    const saibunruiRow = document.getElementById('saibunruiRow');
    if (saibunruiRow) saibunruiRow.style.display = 'none';

    const l1 = (document.getElementById('大分類(カテゴリ)')?.value||'').trim();
    const l2 = (document.getElementById('中分類(カテゴリ)')?.value||'').trim();
    debug.log(`中分類の値: "${l2}"`);
    if (l2) {
      const smalls = uniqKeepOrder(CAT_ROWS.filter(r=>r.大分類===l1 && r.中分類===l2).map(r=>r.小分類));
      fillSelectSafe(document.getElementById('小分類(カテゴリ)'), smalls);
    }

    // === 靴の場合、サイズプルダウンを靴用サイズに切り替え ===
    updateSizeOptions(l2);

    refreshItems();
  }

  function onL3Changed() {
    resetSelect('細分類(カテゴリ)');
    resetSelect('細分類2');
    resetSelect('アイテム名', false);
    const l1 = (document.getElementById('大分類(カテゴリ)')?.value||'').trim();
    const l2 = (document.getElementById('中分類(カテゴリ)')?.value||'').trim();
    const l3 = (document.getElementById('小分類(カテゴリ)')?.value||'').trim();
    const saibunruiRow = document.getElementById('saibunruiRow');

    if (l3) {
      const mins = uniqKeepOrder(CAT_ROWS.filter(r=>r.大分類===l1 && r.中分類===l2 && r.小分類===l3).map(r=>r.細分類));
      fillSelectSafe(document.getElementById('細分類(カテゴリ)'), mins);

      // 細分類の選択肢がある場合のみ表示
      if (mins.length > 0 && saibunruiRow) {
        saibunruiRow.style.display = '';
      } else if (saibunruiRow) {
        saibunruiRow.style.display = 'none';
      }
    } else {
      // 小分類が未選択の場合は非表示
      if (saibunruiRow) saibunruiRow.style.display = 'none';
    }
    refreshItems();
  }

  function onL4Changed() {
    resetSelect('細分類2');
    resetSelect('アイテム名', false);
    const l1 = (document.getElementById('大分類(カテゴリ)')?.value||'').trim();
    const l2 = (document.getElementById('中分類(カテゴリ)')?.value||'').trim();
    const l3 = (document.getElementById('小分類(カテゴリ)')?.value||'').trim();
    const l4 = (document.getElementById('細分類(カテゴリ)')?.value||'').trim();
    if (l4) {
      const fin2 = uniqKeepOrder(CAT_ROWS.filter(r=>r.大分類===l1 && r.中分類===l2 && r.小分類===l3 && r.細分類===l4).map(r=>r.細分類2));
      fillSelectSafe(document.getElementById('細分類2'), fin2);
    }
    refreshItems();
  }

  function onL5Changed() {
    refreshItems();
  }

  function collect() {
    const d={};
    FIELD_IDS.forEach(k=>{
      const el = document.getElementById(k);
      if (!el) return;
      const v=(el.value||'').trim();
      if (v !== '') d[k]=v;
    });

    // サイズ(表記)の特殊処理: トップス、ボトムス、靴のいずれかの値を使用
    const sizeHyokiTop = _val('サイズ(表記)_トップス');
    const sizeHyokiBottom = _val('サイズ(表記)_ボトムス');
    const sizeHyokiShoes = _val('サイズ(表記)_靴');
    const sizeHyoki = sizeHyokiTop || sizeHyokiBottom || sizeHyokiShoes;
    if (sizeHyoki) {
      d['サイズ(表記)'] = sizeHyoki;
    }

    // === 画像URLを追加（最大3枚） ===
    if (uploadedImages && uploadedImages.length > 0) {
      uploadedImages.forEach((img, index) => {
        if (index < 3) {
          d[`画像URL${index + 1}`] = img.data; // data URLをそのまま保存
        }
      });
      debug.log(`画像URLを追加しました: ${uploadedImages.length}枚`);
    }

    // === AI生成履歴を追加 ===
    debug.log(`AI_GENERATED_TEXT: "${AI_GENERATED_TEXT ? AI_GENERATED_TEXT.substring(0, 50) + '...' : '(空)'}"`);
    if (AI_GENERATED_TEXT && AI_GENERATED_TEXT.trim() !== '') {
      const aiHistory = {
        timestamp: new Date().toISOString(),
        text: AI_GENERATED_TEXT,
        imageCount: uploadedImages ? uploadedImages.length : 0,
        brandName: _val('ブランド(英語)') || _val('商品名_ブランド(英語)') || '',
        itemName: _val('アイテム名') || ''
      };
      const historyJson = JSON.stringify(aiHistory);
      d['AI生成履歴'] = historyJson;
      debug.log(`AI生成履歴を追加しました (${historyJson.length}文字)`);
    } else {
      debug.log('AI生成履歴は空のためスキップしました');
    }

    return d;
  }

  function frontValidate(d) {
    const name = d['商品名(タイトル)'] || '';
    const len = Array.from(name).length;
    if (NAME_LIMIT_MODE === 'block' && len > NAME_LIMIT) {
      return `NG(NAME): 商品名(タイトル)は${NAME_LIMIT}文字以内にしてください（現在${len}文字）`;
    }
    const desc = d['商品の説明'] || '';
    const dlen = Array.from(desc).length;
    if (DESC_LIMIT_MODE === 'block' && dlen > DESC_LIMIT) {
      return `NG(DESC): 商品の説明は${DESC_LIMIT}文字以内にしてください（現在${dlen}文字）`;
    }
    if (d['仕入金額'] && isNaN(Number(d['仕入金額']))) return "NG(FORMAT): 仕入金額は数値で入力してください";
    if (d['出品金額'] && isNaN(Number(d['出品金額']))) return "NG(FORMAT): 出品金額は数値で入力してください";
    return '';
  }

  function onSave() {
    updateNamePreview();
    updateDesc();
    const d = collect();
    const ng = frontValidate(d);
    if (ng) {
      return show(ng);
    }
    show('送信中…');

    if (!(google && google.script && google.script.run)) {
      show('NG(ENV): google.script.run が無効です');
      return;
    }
    google.script.run
      .withSuccessHandler(function(result) {
        show(result);
        // 保存成功後も商品の説明エリアの高さを保持
        const descTextarea = document.getElementById('商品の説明');
        if (descTextarea) {
          autoResizeTextarea(descTextarea);
        }
        // 保存成功後に開閉状態と管理番号配置を保存
        saveDescriptionBlocksCollapseState();
        saveTitleBlocksCollapseState();
        saveManagementNumberPlacementSettings();
        console.log('保存成功：開閉状態と管理番号配置を保存しました');

        // === 保存成功後に画像データとAI生成テキストをクリア ===
        if (uploadedImages && uploadedImages.length > 0) {
          uploadedImages = [];
          // プレビューも非表示
          const container = document.getElementById('imagePreviewContainer');
          if (container) {
            container.style.display = 'none';
          }
          // ファイル入力もリセット
          const fileInput = document.getElementById('productImages');
          if (fileInput) {
            fileInput.value = '';
          }
          debug.log('保存成功後に画像データをクリアしました');
        }
        if (AI_GENERATED_TEXT) {
          AI_GENERATED_TEXT = '';
          debug.log('保存成功後にAI生成テキストをクリアしました');
        }
      })
      .withFailureHandler(function(error) {
        show(`NG(UNKNOWN): ${error && error.message ? error.message : error}`);
      })
      .saveProduct(d);
  }

  /**
   * フォーム全体をリセット
   * すべての入力フィールドをクリアし、デフォルト値（配送情報、仕入・出品情報）を再適用
   * 管理番号の配置設定と形式は保持される（ユーザーの運用方針のため）
   * @throws {Error} リセット処理中にエラーが発生した場合
   */
  function onReset() {
    try {
      console.log('=== リセット開始 ===');

      // 0. AI生成文をクリア
      AI_GENERATED_TEXT = '';

      // 0-1. 画像データをクリア
      if (uploadedImages && uploadedImages.length > 0) {
        uploadedImages = [];
        const container = document.getElementById('imagePreviewContainer');
        if (container) {
          container.style.display = 'none';
        }
        // ファイル入力もリセット
        const fileInput = document.getElementById('productImages');
        if (fileInput) {
          fileInput.value = '';
        }
        console.log('画像データをクリアしました');
      }

      // 1. すべての入力フィールドをクリア
      FIELD_IDS.forEach(k=>{
        const el=document.getElementById(k);
        if(el) {
          el.value='';
          console.log(`クリア: ${k}`);
        }
      });

    // 2. カテゴリプルダウンをリセット
    ['中分類(カテゴリ)','小分類(カテゴリ)','細分類(カテゴリ)','細分類2'].forEach(id=> resetSelect(id, true));
    const l1 = document.getElementById('大分類(カテゴリ)');
    if (l1) l1.value='';

    // 細分類行を非表示
    const saibunruiRow = document.getElementById('saibunruiRow');
    if (saibunruiRow) saibunruiRow.style.display = 'none';

    // 3. その他のフィールドをクリア
    ['サイズ','商品の状態','アイテム名','商品名_アイテム名',
     '商品属性1_カテゴリ','商品属性1_値','商品属性2_カテゴリ','商品属性2_値',
     '商品属性3_カテゴリ','商品属性3_値']
    .forEach(id=>{
      const el = document.getElementById(id);
      if (el) el.value = '';
    });

    // 4. セールスワードをリセット
    try {
      resetKeywordDropdown();
      const categorySelect = document.getElementById('セールスワード(カテゴリ)');
      if (categorySelect) categorySelect.value = '';

      // デフォルトセールスワードを再適用
      if (typeof defaultSalesword !== 'undefined' && defaultSalesword && defaultSalesword.カテゴリ && defaultSalesword.セールスワード) {
        setTimeout(() => {
          applyDefaultSalesword(defaultSalesword);
          console.log('デフォルトセールスワードを再適用しました');
        }, 100);
      }
    } catch (error) {
      console.error('セールスワードリセットエラー:', error);
    }

    // 5. 商品状態(詳細)をリセット
    const detailInput = document.getElementById('商品状態詳細');
    if (detailInput) detailInput.value = '';

    // 6. 素材フィールドをリセット
    const materialItems = document.querySelectorAll('.material-item');
    materialItems.forEach((item, index) => {
      if (index === 0) {
        const locationSelect = item.querySelector(`#素材1_箇所`);
        const type1Select = item.querySelector(`#素材1_種類1`);
        const percent1Input = item.querySelector(`#素材1_％1`);
        const type2Select = item.querySelector(`#素材1_種類2`);
        const percent2Input = item.querySelector(`#素材1_％2`);
        if (locationSelect) locationSelect.value = '';
        if (type1Select) type1Select.value = '';
        if (percent1Input) percent1Input.value = '';
        if (type2Select) type2Select.value = '';
        if (percent2Input) percent2Input.value = '';
      } else {
        item.remove();
      }
    });
    materialCount = 1;
    updateRemoveButtons();

    // 6.5. カラーフィールドをリセット
    const colorItems = document.querySelectorAll('.color-item');
    colorItems.forEach((item, index) => {
      if (index === 0) {
        const colorSelect = item.querySelector(`#カラー1`);
        if (colorSelect) colorSelect.value = '';
      } else {
        item.remove();
      }
    });
    colorCount = 1;
    updateColorRemoveButtons();

    // 6.6. 商品属性フィールドをリセット
    const attributeItems = document.querySelectorAll('.attribute-item');
    attributeItems.forEach((item, index) => {
      if (index === 0) {
        // 1個目はフィールドをクリア
        const categorySelect = item.querySelector(`#商品属性1_カテゴリ`);
        const valueSelect = item.querySelector(`#商品属性1_値`);
        if (categorySelect) categorySelect.value = '';
        if (valueSelect) {
          valueSelect.value = '';
          valueSelect.disabled = true;
        }
      } else {
        // 2個目以降は削除
        item.remove();
      }
    });
    attributeCount = 1;
    updateAttributeRemoveButtons();
    updateAttributeFields();

    // 6.7. AI用商品属性をクリア
    const aiAttributesField = document.getElementById('AI用商品属性');
    if (aiAttributesField) aiAttributesField.value = '';

    // 6.8. 品番・型番をクリア
    const modelNumberField = document.getElementById('品番型番');
    if (modelNumberField) modelNumberField.value = '';

    // 7. サイズ関連をリセット
    const shoulderLabel = document.getElementById('shoulderWidthLabel');
    if (shoulderLabel) shoulderLabel.textContent = '肩幅';

    const sizeHyokiTop = document.getElementById('サイズ(表記)_トップス');
    const sizeHyokiBottom = document.getElementById('サイズ(表記)_ボトムス');
    const sizeHyokiShoes = document.getElementById('サイズ(表記)_靴');
    const otherSizeShoes = document.getElementById('その他のサイズ表記_靴');
    const usualSizeShoes = document.getElementById('普段のサイズ_靴');
    const fitShoes = document.getElementById('フィット感_靴');

    if (sizeHyokiTop) sizeHyokiTop.value = '';
    if (sizeHyokiBottom) sizeHyokiBottom.value = '';
    if (sizeHyokiShoes) sizeHyokiShoes.value = '';
    if (otherSizeShoes) otherSizeShoes.value = '';
    if (usualSizeShoes) usualSizeShoes.value = '';
    if (fitShoes) fitShoes.value = '';

    const sizeSection = document.getElementById('sizeSection');
    if (sizeSection) sizeSection.style.display = 'none';

    const sizeIconDisplay = document.getElementById('sizeIconDisplay');
    const sizeLabelDisplay = document.getElementById('sizeLabelDisplay');
    if (sizeIconDisplay) sizeIconDisplay.textContent = '👕';
    if (sizeLabelDisplay) sizeLabelDisplay.textContent = 'サイズ';

    // 8. 配送デフォルトを適用
    applyShippingDefaults();

    // 8-2. 仕入・出品デフォルトを適用
    applyProcureListingDefaults();

    // 9. 管理番号関連をリセット
    const p1 = document.getElementById('prefix1');
    if (p1) {
      p1.value = '';
      console.log('prefix1をクリアしました');
    }
    const shelfField = document.getElementById('棚番号');
    if (shelfField) {
      shelfField.value = '';
      console.log('棚番号をクリアしました');
    }

    // 動的に生成される管理番号フィールドをクリア
    const mgmtShelfFirst = document.getElementById('mgmt_shelf_first');
    const mgmtShelfSecond = document.getElementById('mgmt_shelf_second');
    const mgmtCustomFirst = document.getElementById('mgmt_custom_first');
    const mgmtCustomSecond = document.getElementById('mgmt_custom_second');
    if (mgmtShelfFirst) mgmtShelfFirst.value = '';
    if (mgmtShelfSecond) mgmtShelfSecond.value = '';
    if (mgmtCustomFirst) mgmtCustomFirst.value = '';
    if (mgmtCustomSecond) mgmtCustomSecond.value = '';

    // 管理番号プレビューをクリア
    const mgmtNumberField = document.getElementById('管理番号');
    if (mgmtNumberField) mgmtNumberField.value = '';

    // 管理番号の配置チェックボックスと形式は保持（ユーザーの好みなので）

    // buildShelf()を呼ぶと値が戻されるのでコメントアウト
    // buildShelf();

    // 10. ブランドフィールドをクリア
    const brandEnBasic = document.getElementById('ブランド(英語)');
    if (brandEnBasic) brandEnBasic.value = '';

    const brandEn = document.getElementById('商品名_ブランド(英語)');
    const brandKana = document.getElementById('商品名_ブランド(カナ)');
    if (brandEn) brandEn.value = '';
    if (brandKana) brandKana.value = '';

    // ブランドチェックボックスをチェック状態に戻す
    const brandEnCheckbox = document.getElementById('商品名_ブランド(英語)_チェック');
    const brandKanaCheckbox = document.getElementById('商品名_ブランド(カナ)_チェック');
    if (brandEnCheckbox) brandEnCheckbox.checked = true;
    if (brandKanaCheckbox) brandKanaCheckbox.checked = true;

    hideSuggest('ブランド(英語)');
    hideSuggest('商品名_ブランド(英語)');
    hideSuggest('商品名_ブランド(カナ)');

    // 11. プレビューをリセット
    const namePreview = document.getElementById('商品名プレビュー');
    if (namePreview) {
      namePreview.value = '';
      console.log('商品名プレビューをクリア');
    }

    const descPreview = document.getElementById('商品の説明');
    if (descPreview) {
      descPreview.value = '';
      console.log('商品の説明をクリア（後でデフォルト値復活）');
    }

    // 12. メッセージをクリア
    show('');

    // 13. ハッシュタグ・割引情報のチェックボックスを全てチェック
    document.querySelectorAll('input[id^="hashtag-checkbox-"]').forEach(cb => {
      cb.checked = true;
    });
    document.querySelectorAll('input[id^="discount-checkbox-"]').forEach(cb => {
      cb.checked = true;
    });

    // 14. 折りたたみ状態をリセット（閉じる）
    const hashtagSection = document.getElementById('hashtagSection');
    const hashtagToggle = document.getElementById('hashtagToggle');
    if (hashtagSection && hashtagToggle) {
      hashtagSection.style.display = 'none';
      hashtagToggle.textContent = '▼';
    }

    const discountSection = document.getElementById('discountSection');
    const discountToggle = document.getElementById('discountToggle');
    if (discountSection && discountToggle) {
      discountSection.style.display = 'none';
      discountToggle.textContent = '▼';
    }

    // 15. プレビューを再構築（商品名は空、商品の説明はデフォルト値）
    console.log('ブランド表示を更新');
    updateBrandDisplay(); // ブランド情報をクリア

    console.log('商品名プレビュー再構築');
    // updateBrandDisplay()が非同期なので、少し待ってから商品名プレビューを更新
    setTimeout(() => {
      updateNamePreview();
      console.log('商品の説明デフォルト値復活');
      updateDescriptionFromDetail();
    }, 100);

    // 16. 画像をクリア
    uploadedImages = [];
    const imageInput = document.getElementById('productImages');
    if (imageInput) imageInput.value = '';
    displayImagePreviews();
    console.log('画像をクリア');

      console.log('=== リセット完了 ===');
    } catch (error) {
      console.error('リセット処理エラー:', error);
      debug.error('onReset エラー:', error);
      alert('リセット処理中にエラーが発生しました。ページを再読み込みしてください。');
    }
  }

  // クリップボードにコピー
  function copyToClipboard(fieldId, buttonId) {
    const field = document.getElementById(fieldId);
    const button = document.getElementById(buttonId);

    if (!field || !field.value.trim()) {
      alert('コピーする内容がありません');
      return;
    }

    // クリップボードにコピー
    navigator.clipboard.writeText(field.value).then(function() {
      // ボタンのテキストを「✓ コピー済み」に変更
      const originalText = button.innerHTML;
      button.innerHTML = '✓ コピー済み';
      button.style.background = '#c8e6c9';
      button.style.borderColor = '#81c784';
      button.style.color = '#2e7d32';

      // 1秒後に元に戻す
      setTimeout(function() {
        button.innerHTML = originalText;
        button.style.background = '#e3f2fd';
        button.style.borderColor = '#90caf9';
        button.style.color = '#1976d2';
      }, 1000);
    }).catch(function(err) {
      console.error('クリップボードへのコピーに失敗しました:', err);
      alert('コピーに失敗しました。ブラウザの設定を確認してください。');
    });
  }

  // テキストエリアの高さを自動調整
  function autoResizeTextarea(textarea) {
    if (!textarea) return;

    // DOMの更新を待ってから実行
    setTimeout(function() {
      console.log('autoResizeTextarea 実行開始');
      console.log('現在の値の長さ:', textarea.value.length);
      console.log('現在の高さ:', textarea.style.height);

      // 一旦高さをリセットしてscrollHeightを正しく取得
      textarea.style.height = 'auto';

      // scrollHeightを取得
      const scrollHeight = textarea.scrollHeight;
      console.log('scrollHeight:', scrollHeight);

      // scrollHeightに基づいて高さを設定（padding + border分を考慮）
      const newHeight = Math.max(120, scrollHeight + 10);
      textarea.style.height = newHeight + 'px';

      console.log('新しい高さ:', newHeight + 'px');
    }, 50);
  }

  function show(t) {
    const el=document.getElementById('msg');
    if (el) el.textContent = t;
  }

  function unifyConditionList(list) {
    const arr = (list||[]).map(v => (v??'').toString().trim()).filter(v=>v);
    const hasCombined = arr.includes('新品、未使用');
    const idxNew = arr.indexOf('新品');
    const idxUnused = arr.indexOf('未使用');
    if (hasCombined && idxNew === -1 && idxUnused === -1) return arr;
    const earliest = Math.min(
      idxNew === -1 ? Infinity : idxNew,
      idxUnused === -1 ? Infinity : idxUnused
    );
    const out = [];
    let combinedInserted = false;
    for (let i=0; i<arr.length; i++) {
      const v = arr[i];
      if (i === earliest && (idxNew !== -1 || idxUnused !== -1)) {
        if (!combinedInserted) {
          out.push('新品、未使用');
          combinedInserted = true;
        }
        continue;
      }
      if (v === '新品' || v === '未使用') continue;
      if (v === '新品、未使用') {
        if (!combinedInserted) {
          out.push(v);
          combinedInserted = true;
        }
        continue;
      }
      out.push(v);
    }
    if (!combinedInserted && (idxNew !== -1 || idxUnused !== -1)) out.unshift('新品、未使用');
    return out;
  }

  /**
   * ひらがなをカタカナに変換（スマホ対応）
   * 例: "ないき" → "ナイキ"
   */
  function hiraganaToKatakana(str) {
    return str.replace(/[\u3041-\u3096]/g, function(match) {
      var chr = match.charCodeAt(0) + 0x60;
      return String.fromCharCode(chr);
    });
  }

  function attachBrandSuggest(inputId, list) {
    console.log(`attachBrandSuggest called for ${inputId} with list length:`, list ? list.length : 'undefined');
    const input = document.getElementById(inputId);
    const panel = document.getElementById('suggest-' + inputId);
    if (!input || !panel) {
      console.log(`Missing elements for ${inputId}: input=${!!input}, panel=${!!panel}`);
      return;
    }
    let activeIndex = -1;
    const limit = 15;
    const render = (items) => {
      panel.innerHTML = '';
      if (!items.length) {
        panel.innerHTML = '<div class="sug-empty">候補なし</div>';
        panel.hidden = false;
        return;
      }

      // ブランド入力フィールドかどうかを判定
      const isBrandField = inputId === 'ブランド(英語)' || inputId === '商品名_ブランド(英語)';

      items.slice(0, limit).forEach((v, i)=>{
        const div = document.createElement('div');

if (isBrandField) {
            // ブランド(英語)の場合は2行表示
            div.className = 'sug-item brand-item';

            const englishName = v;
            // ペアデータから正確なカナ読みを取得
            const pairIndex = BRAND_INDEX_MAP.get(englishName);
            const kanaName = pairIndex !== undefined && BRAND_PAIRS[pairIndex] ? BRAND_PAIRS[pairIndex].kana : '';

            const escapedEnglishName = String(englishName).replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g,
  '&gt;').replace(/"/g, '&quot;');
            const escapedKanaName = String(kanaName).replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g,
  '&gt;').replace(/"/g, '&quot;');

            div.innerHTML = `
              <div class="brand-english">${escapedEnglishName}</div>
              <div class="brand-kana">${escapedKanaName}</div>
            `;
          } else {
          // その他のフィールドは従来通り1行表示
          div.className = 'sug-item';
          div.textContent = v;
        }

        div.addEventListener('mousemove', ()=> {
          Array.from(panel.querySelectorAll('.sug-item')).forEach(x=> x.classList.remove('active'));
          div.classList.add('active');
          activeIndex = i;
        });
        div.addEventListener('mousedown', (e)=> {
          e.preventDefault();
        });
        div.addEventListener('click', ()=> {
            // ブランド(英語)の2行表示の場合は英語名のみを取得
            if ((inputId === 'ブランド(英語)' || inputId === '商品名_ブランド(英語)') &&
  div.classList.contains('brand-item')) {
              const englishDiv = div.querySelector('.brand-english');
              input.value = englishDiv ? englishDiv.textContent : '';
            } else {
              input.value = v;
            }
            hide();
            // 基本情報のブランド(英語)選択時は、先に商品名ブロックに反映してから商品名プレビューを更新
            if (inputId === 'ブランド(英語)') {
              updateBrandDisplay();
              updateNamePreview();
              updateDescriptionFromDetail();
            } else {
              updateNamePreview();
              updateDescriptionFromDetail();
            }
          });
        panel.appendChild(div);
      });
      panel.hidden = false;
    };
    const hide = ()=>{
      panel.hidden = true;
      activeIndex = -1;
    };
    const hideLater = ()=> setTimeout(hide, 100);
    const doFilter = ()=>{
      let q = (input.value || '').trim();

      // ひらがなをカタカナに変換（スマホ対応）
      // 例: "ないき" → "ナイキ"
      if (inputId === 'ブランド(英語)' || inputId === '商品名_ブランド(英語)') {
        q = hiraganaToKatakana(q);
      }

      // デバッグ用ログ
      console.log(`doFilter called for ${inputId}, query: "${q}", list length: ${list ? list.length : 'undefined'}`);

      // リストが存在しない場合は何もしない
      if (!Array.isArray(list) || list.length === 0) {
        console.log(`No data available for ${inputId}`);
        hide();
        return;
      }

      if (!q) {
        hide();
        return;
      }

      // 短すぎる検索文字列の場合は処理を制限（パフォーマンス向上）
      if (inputId === 'ブランド(英語)' && q.length < 2 && list.length > 10000) {
        hide();
        return;
      }

      let filtered;

if (inputId === '商品名_ブランド(英語)' || inputId === 'ブランド(英語)') {
        // ブランド(英語)の場合は英語名とカナ読み両方で検索（ペアデータ使用）
        const qq = q.toLowerCase();
        filtered = list.filter(v=>{
          const englishName = String(v).toLowerCase();

          // 完全一致検索
          if (englishName.indexOf(qq) !== -1) {
            return true;
          }

          // 単語境界での部分一致検索（スペース区切り）
          const words = englishName.split(/\s+/);
          if (words.some(word => word.startsWith(qq))) {
            return true;
          }

          // カナ読み検索（ペアデータから正確に取得）
          const pairIndex = BRAND_INDEX_MAP.get(v);
          if (pairIndex !== undefined && BRAND_PAIRS[pairIndex]) {
            const kanaName = String(BRAND_PAIRS[pairIndex].kana || '').toLowerCase();

            // カナ読み完全一致
            if (kanaName.indexOf(qq) !== -1) {
              return true;
            }

            // カナ読み単語境界での部分一致
            const kanaWords = kanaName.split(/[\s・]+/);
            if (kanaWords.some(word => word.startsWith(qq))) {
              return true;
            }
          }

          return false;
        });
        } else if (inputId === 'ブランド(英語)') {
          // 基本情報ブランド(英語)の場合も同様の柔軟検索
          const qq = q.toLowerCase();
          filtered = list.filter(v=>{
            const englishName = String(v).toLowerCase();

            // 完全一致検索
            if (englishName.indexOf(qq) !== -1) {
              return true;
            }

            // 単語境界での部分一致検索（スペース区切り）
            const words = englishName.split(/\s+/);
            if (words.some(word => word.startsWith(qq))) {
              return true;
            }

            // カナ読み検索（ペアデータから正確に取得）
            const pairIndex = BRAND_INDEX_MAP.get(v);
            if (pairIndex !== undefined && BRAND_PAIRS[pairIndex]) {
              const kanaName = String(BRAND_PAIRS[pairIndex].kana || '').toLowerCase();

              // カナ読み完全一致
              if (kanaName.indexOf(qq) !== -1) {
                return true;
              }

              // カナ読み単語境界での部分一致
              const kanaWords = kanaName.split(/[\s・]+/);
              if (kanaWords.some(word => word.startsWith(qq))) {
                return true;
              }
            }

            return false;
          });
        } else {
          // その他のフィールドは従来通り（case-insensitive対応）
          const qq = q.toLowerCase();
          filtered = list.filter(v=>{
            const s = String(v).toLowerCase();
            return s.indexOf(qq) !== -1;
          });
        }

      console.log(`Filtered results for ${inputId}: ${filtered.length} items`);
      render(filtered);
    };
    input.addEventListener('input', () => {
      doFilter();
      // 商品名ブロックのブランドフィールドの場合、常にプレビューを更新（空の場合も含む）
      if (inputId === '商品名_ブランド(英語)' || inputId === '商品名_ブランド(カナ)') {
        updateNamePreview();
      }
    });
    input.addEventListener('focus', doFilter);
    input.addEventListener('blur', hideLater);
    input.addEventListener('keydown', (e)=>{
      if (panel.hidden) return;
      const items = Array.from(panel.querySelectorAll('.sug-item'));
      if (!items.length) return;
      if (e.key === 'ArrowDown') {
        e.preventDefault();
        activeIndex = (activeIndex + 1) % items.length;
        items.forEach(x=>x.classList.remove('active'));
        items[activeIndex].classList.add('active');
        items[activeIndex].scrollIntoView({ block:'nearest' });
      } else if (e.key === 'ArrowUp') {
        e.preventDefault();
        activeIndex = (activeIndex - 1 + items.length) % items.length;
        items.forEach(x=>x.classList.remove('active'));
        items[activeIndex].classList.add('active');
        items[activeIndex].scrollIntoView({ block:'nearest' });
      } else if (e.key === 'Enter') {
        if (activeIndex >= 0) {
          e.preventDefault();
          const selectedItem = items[activeIndex];

          // ブランド(英語)の2行表示の場合は英語名のみを取得
          if ((inputId === 'ブランド(英語)' || inputId === '商品名_ブランド(英語)') &&
  selectedItem.classList.contains('brand-item')) {
            const englishDiv = selectedItem.querySelector('.brand-english');
            input.value = englishDiv ? englishDiv.textContent : '';
          } else {
            input.value = selectedItem.textContent || '';
          }

          hide();
          updateNamePreview();

          // ブランド(英語)の場合は追加の更新処理
          if (inputId === 'ブランド(英語)') {
            updateBrandDisplay();
            updateDescriptionFromDetail();
          }
        }
      } else if (e.key === 'Escape') {
        hide();
      }
    });
    function hideExternal() {
      hide();
    }
    input._hideSuggest = hideExternal;
  }

  function hideSuggest(inputId) {
    const input = document.getElementById(inputId);
    if (input && input._hideSuggest) input._hideSuggest();
  }

  // ================= 初期化処理 =================
  (function init() {
    // 頭文字・棚番号プルダウンを初期化
    initPrefix1();
    buildShelf();
    const p1 = document.getElementById('prefix1');
    if (p1) p1.addEventListener('change', buildShelf);
    const sh = document.getElementById('棚番号');
    if (sh) sh.addEventListener('change', requestNextManagementNumber);

    // カテゴリマスタ取得
    if (google && google.script && google.script.run && google.script.run.getCategoryRows) {
      google.script.run.withSuccessHandler(res=>{
        if (!res || !res.ok) {
          show(res && res.msg ? res.msg : 'NG(MASTER): マスタを取得できませんでした');
          return;
        }
        CAT_ROWS = (res.rows || []).map(r=>({
          大分類:String(r.大分類||'').trim(),
          中分類:String(r.中分類||'').trim(),
          小分類:String(r.小分類||'').trim(),
          細分類:String(r.細分類||'').trim(),
          細分類2:String(r.細分類2||'').trim(),
          アイテム名:String(r.アイテム名||'').trim(),
        }));
        const l1s = uniqKeepOrder(CAT_ROWS.map(r=>r.大分類));
        fillSelectSafe(document.getElementById('大分類(カテゴリ)'), l1s);

        // カテゴリプルダウンのイベントリスナーを設定
        const l1Select = document.getElementById('大分類(カテゴリ)');
        const l2Select = document.getElementById('中分類(カテゴリ)');
        const l3Select = document.getElementById('小分類(カテゴリ)');
        const l4Select = document.getElementById('細分類(カテゴリ)');
        const l5Select = document.getElementById('細分類2');
        const itemSelect = document.getElementById('アイテム名');
        if (l1Select) {
          l1Select.addEventListener('change', onL1Changed);
          debug.log('大分類のイベントリスナーを設定しました');
        }
        if (l2Select) {
          l2Select.addEventListener('change', onL2Changed);
          debug.log('中分類のイベントリスナーを設定しました');
        }
        if (l3Select) {
          l3Select.addEventListener('change', onL3Changed);
          debug.log('小分類のイベントリスナーを設定しました');
        }
        if (l4Select) l4Select.addEventListener('change', onL4Changed);
        if (l5Select) l5Select.addEventListener('change', onL5Changed);
        if (itemSelect) itemSelect.addEventListener('change', updateItemNameDisplay);

        // 基本情報のサイズプルダウンのイベントリスナーを設定（商品の説明ブロックに連動）
        const sizeSelect = document.getElementById('サイズ');
        if (sizeSelect) {
          sizeSelect.addEventListener('change', syncBasicSizeToDescription);
          debug.log('サイズプルダウンのイベントリスナーを設定しました');
        }

        wirePreviewWatchers();
        updateNamePreview();
        adjustPreviewHeight();
      }).withFailureHandler(e=> show(`NG(MASTER): ${e && e.message ? e.message : e}`)).getCategoryRows();
    }

    // マスタオプション取得
    if (google && google.script && google.script.run && google.script.run.getMasterOptions) {
      google.script.run.withSuccessHandler(opts=>{
        if (!opts || typeof opts !== 'object') {
          show('NG(MASTER): 空の応答');
          return;
        }

        // マスターオプションをグローバル変数に保存
        MASTER_OPTIONS = opts;

        const fillSel=(id,arr)=>{
          const sel=document.getElementById(id);
          if(!sel) return;
          sel.innerHTML='<option value="">--</option>';
          (arr||[]).forEach(v=> sel.insertAdjacentHTML('beforeend', `<option value="${v}">${v}</option>`));
        };

        // 基本フィールド
        fillSel('担当者', opts['担当者']||[]);
        fillSel('仕入先', opts['仕入先']||[]);
        fillSel('生地・素材・質感系', opts['生地・素材・質感系']||[]);
        fillSel('サイズ', opts['サイズ']||[]);
        fillSel('商品の状態', unifyConditionList(opts['商品の状態']||[]));

        // サイズ(表記)の選択肢を設定
        fillSel('サイズ(表記)_トップス', opts['サイズ(表記)']||[]);
        fillSel('サイズ(表記)_ボトムス', opts['サイズ(表記)']||[]);

// ブランドデータ（従来の配列形式は互換性のため保持）
        BRAND_EN = Array.isArray(opts['ブランド(英語)']) ? opts['ブランド(英語)'] : [];
        BRAND_KANA = Array.isArray(opts['ブランド(カナ)']) ? opts['ブランド(カナ)'] : [];

        // ブランドペアデータを別途取得
        google.script.run
          .withSuccessHandler(function(pairs) {
            console.log('ブランドペアデータ取得成功:', pairs.length, '件');
            BRAND_PAIRS = pairs || [];

            // ペアデータから英語とカナの配列を再構築
            BRAND_EN = BRAND_PAIRS.map(pair => pair.english);
            BRAND_KANA = BRAND_PAIRS.map(pair => pair.kana);

            // ペアデータ用インデックスマップを構築
            buildBrandIndexMap();

            // ブランド候補を再設定（ペアデータ使用）
  attachBrandSuggest('ブランド(英語)', BRAND_EN);

  // 商品名ブロック用のブランド候補を設定
  attachBrandSuggest('商品名_ブランド(英語)', BRAND_EN);
  attachBrandSuggest('商品名_ブランド(カナ)', BRAND_KANA);

            console.log('ブランドペアデータ設定完了 - EN:', BRAND_EN.length, 'KANA:', BRAND_KANA.length);
          })
          .withFailureHandler(function(error) {
            console.error('ブランドペアデータ取得エラー:', error);
            // エラー時は従来の配列方式にフォールバック
  buildBrandIndexMap();
  attachBrandSuggest('ブランド(英語)', BRAND_EN);
  attachBrandSuggest('商品名_ブランド(英語)', BRAND_EN);
  attachBrandSuggest('商品名_ブランド(カナ)', BRAND_KANA);
          })
          .getBrandPairs();

        // タイトル情報フィールド
        [
          '季節感・機能性','着用シーン・イベント','見た目・印象','トレンド表現',
          'サイズ感・体型カバー','年代・テイスト・スタイル','カラー/配色/トーン','柄・模様',
          'ディテール・仕様','シルエット/ライン','ネックライン','襟・衿',
          '袖・袖付け','丈','革/加工','毛皮/加工','生産国'
        ].forEach(name => fillSel(name, opts[name]||[]));

        // 出品・配送関連
        fillSel('出品先', opts['出品先']||[]);
        fillSel('配送料の負担', opts['配送料の負担']||[]);
        fillSel('配送の方法', opts['配送の方法']||[]);
        fillSel('発送元の地域', opts['発送元の地域']||[]);
        fillSel('発送までの日数', opts['発送までの日数']||[]);

applyShippingDefaults();
applyProcureListingDefaults();

// ★★★ ここから追加 ★★★
// サイズ・商品の状態などのイベントリスナーを設定
const sizeSelect = document.getElementById('サイズ');
if (sizeSelect) {
  sizeSelect.removeEventListener('change', updateNamePreview);
  sizeSelect.addEventListener('change', updateNamePreview);
  console.log('サイズプルダウンのイベントリスナー設定完了');
}

const conditionSelect = document.getElementById('商品の状態');
if (conditionSelect) {
  conditionSelect.removeEventListener('change', updateDescriptionFromDetail);
  conditionSelect.addEventListener('change', updateDescriptionFromDetail);
  conditionSelect.removeEventListener('change', updateConditionButtons);
  conditionSelect.addEventListener('change', updateConditionButtons);
  console.log('商品の状態プルダウンのイベントリスナー設定完了');
}

const staffSelect = document.getElementById('担当者');
if (staffSelect) {
  staffSelect.removeEventListener('change', updateNamePreview);
  staffSelect.addEventListener('change', updateNamePreview);
  console.log('担当者プルダウンのイベントリスナー設定完了');
}

  // グローバルにマスターオプションを保存（階層式セレクター用）
  window.globalMasterOptions = opts;

  // ブランド候補設定は getBrandPairs() の成功時に実行される

        wirePreviewWatchers();
        updateNamePreview();
        adjustPreviewHeight();

      }).withFailureHandler(e=> show(`NG(MASTER): ${e && e.message ? e.message : e}`)).getMasterOptions();
    }

// 階層式商品属性セレクター設定
  setupAttributeSelectors();

  // 動的サイズシステム設定
  setupSizeSystem();

    // セールスワード専用初期化
    initializeSalesWords();

    // 設定マスタ全体を読み込み（配置順序を含む）
    loadAllConfig();

    // 設定マスタから商品状態ボタンを読み込み
    loadConditionButtonsFromConfig();

    // 設定マスタからハッシュタグ設定を読み込み
    loadHashtagConfig();

    // 設定マスタから割引情報を読み込み
    loadDiscountConfig();

    // 設定マスタから配送デフォルトを読み込み
    loadShippingDefaults();

    // 設定マスタから仕入・出品デフォルトを読み込み
    loadProcureListingDefaults();

    // 設定マスタから商品名ブロック並び順を読み込み
    loadTitleBlockOrder();

    // イベントリスナー設定
    const l1=document.getElementById('大分類(カテゴリ)');
    if (l1) l1.addEventListener('change', onL1Changed);
    const l2=document.getElementById('中分類(カテゴリ)');
    if (l2) l2.addEventListener('change', onL2Changed);
    const l3=document.getElementById('小分類(カテゴリ)');
    if (l3) l3.addEventListener('change', onL3Changed);
    const l4=document.getElementById('細分類(カテゴリ)');
    if (l4) l4.addEventListener('change', onL4Changed);
    const l5=document.getElementById('細分類2');
    if (l5) l5.addEventListener('change', onL5Changed);
    const itemName=document.getElementById('アイテム名');
    if (itemName) itemName.addEventListener('change', updateItemNameDisplay);

    // セールスワード専用イベント設定
    setupSalesWordEventListeners();

    wireDescWatcher();

    // 商品状態(詳細)イベントリスナー設定を追加
    setupDetailEventListener();

    // クイック挿入ボタン設定
    setupQuickInsertButtons();

    // 素材マスターデータ初期化
    initializeMaterialMasters();

    // カラーマスターデータ初期化
    initializeColorMasters();

    // 管理番号UI初期化（動的セグメント対応）
    initManagementNumberUI();

    // 素材追加ボタンのイベントリスナー
    const addBtn = document.getElementById('addMaterialBtn');
    if (addBtn) {
      addBtn.addEventListener('click', addMaterial);
    }

    // カラー追加ボタンのイベントリスナー
    const addColorBtnEl = document.getElementById('addColorBtn');
    if (addColorBtnEl) {
      addColorBtnEl.addEventListener('click', addColor);
    }

    // 商品属性追加ボタンのイベントリスナー
    const addAttributeBtn = document.getElementById('addAttributeBtn');
    if (addAttributeBtn) {
      addAttributeBtn.addEventListener('click', addAttribute);
    }

    // 初期の商品属性セットアップ
    populateAttributeCategory(1);
    setupAttributeSelector(1);
    updateAttributeRemoveButtons();

    // 素材入力フィールドの変更監視
    document.addEventListener('change', function(e) {
      if (e.target.classList.contains('material-location') ||
          e.target.classList.contains('material-type') ||
          e.target.classList.contains('material-percent')) {
        updateDescriptionFromDetail();
      }
    });

    // 商品状態履歴を取得してオートコンプリート設定
    if (google && google.script && google.script.run) {
      google.script.run
        .withSuccessHandler(function(history) {
          CONDITION_HISTORY = history || [];
          console.log('商品状態履歴取得完了:', CONDITION_HISTORY.length, '件');

          // オートコンプリートを設定
          attachConditionSuggest('商品状態詳細', CONDITION_HISTORY);
        })
        .withFailureHandler(function(error) {
          console.error('商品状態履歴取得エラー:', error);
          // エラー時もボタンは使えるようにする
          attachConditionSuggest('商品状態詳細', []);
        })
        .getProductConditionHistory();
    }

    window.addEventListener('resize', ()=>{
      adjustPreviewHeight();
      adjustDescHeight();
    });
  })();

  // ================= 動的サイズ機能 =================
  function setupSizeSystem() {
    // サイズプルダウンに数値選択肢を設定
    const sizeFields = ['肩幅', '身幅', '袖丈', '着丈', 'ウエスト', 'ヒップ', '股上', '股下'];

    sizeFields.forEach(fieldId => {
      const select = document.getElementById(fieldId);
      if (select) {
        // 20cm〜120cmまで1cm刻みで選択肢を生成
  for (let i = 20; i <= 120; i += 1) {
    const option = document.createElement('option');
    option.value = i.toString();
    option.textContent = i.toString();
    select.appendChild(option);
  }

        // サイズ選択時に説明文を更新
        select.addEventListener('change', updateDescriptionFromDetail);
      }
    });

    // 小分類変更時のサイズ表示切り替え
    const subcategorySelect = document.getElementById('小分類(カテゴリ)');
    if (subcategorySelect) {
      subcategorySelect.addEventListener('change', updateSizeDisplay);
    }

    // 初期表示設定
    updateSizeDisplay();
  }

  // カテゴリに応じたアイコンとラベルを取得
  function getSizeIconAndLabel(subcategory) {
    // アイコンマッピング（大分類・中分類・アイテム名に対応）
    const iconMap = {
      // トップス系
      'Tシャツ': { icon: '👕', label: 'Tシャツ' },
      'シャツ': { icon: '👔', label: 'シャツ' },
      'ニット': { icon: '👕', label: 'ニット' },
      'セーター': { icon: '👕', label: 'セーター' },
      'パーカー': { icon: '🧥', label: 'パーカー' },
      'スウェット': { icon: '👕', label: 'スウェット' },
      'ジャケット': { icon: '🧥', label: 'ジャケット' },
      'ブレザー': { icon: '🧥', label: 'ブレザー' },
      'カーディガン': { icon: '🧥', label: 'カーディガン' },
      'ベスト': { icon: '🦺', label: 'ベスト' },
      'タンクトップ': { icon: '🎽', label: 'タンクトップ' },
      'キャミソール': { icon: '👗', label: 'キャミソール' },
      'ブラウス': { icon: '👚', label: 'ブラウス' },
      'チュニック': { icon: '👚', label: 'チュニック' },
      'ワンピース': { icon: '👗', label: 'ワンピース' },
      'コート': { icon: '🧥', label: 'コート' },
      'ダウンジャケット': { icon: '🧥', label: 'ダウンジャケット' },
      'アウター': { icon: '🧥', label: 'アウター' },
      'ジャンパー': { icon: '🧥', label: 'ジャンパー' },

      // ボトムス系
      'パンツ': { icon: '👖', label: 'パンツ' },
      'ジーンズ': { icon: '👖', label: 'ジーンズ' },
      'デニム': { icon: '👖', label: 'デニム' },
      'チノパン': { icon: '👖', label: 'チノパン' },
      'スラックス': { icon: '👔', label: 'スラックス' },
      'ショートパンツ': { icon: '🩳', label: 'ショートパンツ' },
      'ハーフパンツ': { icon: '🩳', label: 'ハーフパンツ' },
      'レギンス': { icon: '👖', label: 'レギンス' },
      'スパッツ': { icon: '👖', label: 'スパッツ' },
      'ジョガーパンツ': { icon: '👖', label: 'ジョガーパンツ' },
      'カーゴパンツ': { icon: '👖', label: 'カーゴパンツ' },
      'スカート': { icon: '👗', label: 'スカート' },
      'ミニスカート': { icon: '👗', label: 'ミニスカート' },
      'マキシスカート': { icon: '👗', label: 'マキシスカート' },
      'プリーツスカート': { icon: '👗', label: 'プリーツスカート' }
    };

    // デフォルトアイコン
    const defaultTops = { icon: '👕', label: 'トップス' };
    const defaultBottoms = { icon: '👖', label: 'パンツ' };

    // 部分一致でマッピング検索
    for (const [key, value] of Object.entries(iconMap)) {
      if (subcategory && subcategory.includes(key)) {
        return value;
      }
    }

    // 見つからない場合はデフォルト
    return null;
  }

  function updateSizeDisplay() {
    const subcategory = _val('小分類(カテゴリ)');
    const sizeSection = document.getElementById('sizeSection');
    const topsSize = document.getElementById('topsSize');
    const bottomsSize = document.getElementById('bottomsSize');
    const shoesSize = document.getElementById('shoesSize');
    const sizeIconDisplay = document.getElementById('sizeIconDisplay');
    const sizeLabelDisplay = document.getElementById('sizeLabelDisplay');

    if (!sizeSection || !topsSize || !bottomsSize || !shoesSize) return;

    // カテゴリマッピング
    const topsCategories = [
      'Tシャツ', 'シャツ', 'ニット', 'セーター', 'パーカー', 'スウェット',
      'ジャケット', 'ブレザー', 'カーディガン', 'ベスト', 'タンクトップ',
      'キャミソール', 'ブラウス', 'チュニック', 'ワンピース',
      'コート', 'ダウンジャケット', 'アウター', 'ジャンパー'
    ];

    const bottomsCategories = [
      'パンツ', 'ジーンズ', 'デニム', 'チノパン', 'スラックス', 'ショートパンツ',
      'ハーフパンツ', 'レギンス', 'スパッツ', 'ジョガーパンツ', 'カーゴパンツ',
      'スカート', 'ミニスカート', 'マキシスカート', 'プリーツスカート'
    ];

    const setCategories = [
      'スーツ', 'セットアップ', 'パジャマ', 'ルームウェア', 'ジャージ',
      'トラックスーツ', 'スポーツウェア', '作業着', 'つなぎ'
    ];

    const shoesCategories = [
      'スニーカー', 'ローファー', 'ブーツ', 'サンダル', 'パンプス',
      'レザーシューズ', 'スポーツシューズ', 'ランニングシューズ',
      'バスケットシューズ', 'スケートシューズ', 'ハイカットスニーカー',
      'ローカットスニーカー', 'スリッポン', 'モカシン', 'デッキシューズ'
    ];

    // 表示状態をリセット
    sizeSection.style.display = 'none';
    topsSize.style.display = 'none';
    bottomsSize.style.display = 'none';
    shoesSize.style.display = 'none';

    if (!subcategory) return;

    // アイコンとラベルを取得
    const iconData = getSizeIconAndLabel(subcategory);

    // ラグラン判定（アイテム名で判定）
    const itemName = _val('アイテム名');
    const isRaglan = itemName && itemName.includes('ラグラン');

    // カテゴリに応じて表示切り替え＆アイコン更新
    if (topsCategories.some(cat => subcategory.includes(cat))) {
      sizeSection.style.display = 'block';
      topsSize.style.display = 'block';
      if (iconData && sizeIconDisplay && sizeLabelDisplay) {
        sizeIconDisplay.textContent = iconData.icon;
        sizeLabelDisplay.textContent = iconData.label;
      }
      // ラグラン例外処理: 肩幅→裄丈
      const shoulderLabel = document.getElementById('shoulderWidthLabel');
      if (shoulderLabel) {
        shoulderLabel.textContent = isRaglan ? '裄丈' : '肩幅';
      }
    } else if (bottomsCategories.some(cat => subcategory.includes(cat))) {
      sizeSection.style.display = 'block';
      bottomsSize.style.display = 'block';
      if (iconData && sizeIconDisplay && sizeLabelDisplay) {
        sizeIconDisplay.textContent = iconData.icon;
        sizeLabelDisplay.textContent = iconData.label;
      }
    } else if (setCategories.some(cat => subcategory.includes(cat))) {
      sizeSection.style.display = 'block';
      topsSize.style.display = 'block';
      bottomsSize.style.display = 'block';
      if (iconData && sizeIconDisplay && sizeLabelDisplay) {
        sizeIconDisplay.textContent = iconData.icon;
        sizeLabelDisplay.textContent = iconData.label;
      }
      // ラグラン例外処理: 肩幅→裄丈
      const shoulderLabel = document.getElementById('shoulderWidthLabel');
      if (shoulderLabel) {
        shoulderLabel.textContent = isRaglan ? '裄丈' : '肩幅';
      }
    } else if (shoesCategories.some(cat => subcategory.includes(cat))) {
      // 靴の場合
      sizeSection.style.display = 'block';
      shoesSize.style.display = 'block';
      if (sizeIconDisplay && sizeLabelDisplay) {
        sizeIconDisplay.textContent = '👟';
        sizeLabelDisplay.textContent = 'サイズ（靴）';
      }

      // サイズ(表記)_靴のselectに選択肢を設定
      const shoesSizeSelect = document.getElementById('サイズ(表記)_靴');
      const basicSizeSelect = document.getElementById('サイズ');
      if (shoesSizeSelect && basicSizeSelect) {
        // 基本情報のサイズプルダウンの選択肢をコピー
        const currentValue = shoesSizeSelect.value;
        shoesSizeSelect.innerHTML = '';

        // 基本情報の全選択肢をコピー
        Array.from(basicSizeSelect.options).forEach(option => {
          const newOption = document.createElement('option');
          newOption.value = option.value;
          newOption.textContent = option.textContent;
          shoesSizeSelect.appendChild(newOption);
        });

        // 基本情報で選択されている値があれば同期
        const basicSize = basicSizeSelect.value;
        if (basicSize) {
          shoesSizeSelect.value = basicSize;
        } else if (currentValue) {
          // 以前の選択値を復元
          shoesSizeSelect.value = currentValue;
        }
      }

      console.log('★★★ updateSizeDisplay() で靴のサイズセクションを表示しました');
    }

    // 説明文を更新
    updateDescriptionFromDetail();
  }

  // グローバル関数設定
  window.onSave = onSave;
  window.onReset = onReset;
  window.initPrefix1 = initPrefix1;
  window.buildShelf = buildShelf;
  window.requestNextManagementNumber = requestNextManagementNumber;
  window.updateDescriptionFromDetail = updateDescriptionFromDetail;
  window.setupDetailEventListener = setupDetailEventListener;

  // ================= 階層式商品属性セレクター =================
  function setupAttributeSelectors() {
    // 商品属性1
    const category1 = document.getElementById('商品属性1_カテゴリ');
    const value1 = document.getElementById('商品属性1_値');
    if (category1 && value1) {
      category1.addEventListener('change', function() {
        updateAttributeValues('商品属性1_カテゴリ', '商品属性1_値');
      });
    }

    // 商品属性2
    const category2 = document.getElementById('商品属性2_カテゴリ');
    const value2 = document.getElementById('商品属性2_値');
    if (category2 && value2) {
      category2.addEventListener('change', function() {
        updateAttributeValues('商品属性2_カテゴリ', '商品属性2_値');
      });
    }

    // 商品属性3
    const category3 = document.getElementById('商品属性3_カテゴリ');
    const value3 = document.getElementById('商品属性3_値');
    if (category3 && value3) {
      category3.addEventListener('change', function() {
        updateAttributeValues('商品属性3_カテゴリ', '商品属性3_値');
      });
    }
  }

  function updateAttributeValues(categoryId, valueId) {
    const categorySelect = document.getElementById(categoryId);
    const valueSelect = document.getElementById(valueId);

    if (!categorySelect || !valueSelect) return;

    const selectedCategory = categorySelect.value;

    // 値プルダウンをリセット
    valueSelect.innerHTML = '<option value="">--カテゴリを選択してください--</option>';
    valueSelect.disabled = true;

    if (!selectedCategory) {
      updateNamePreview();
      return;
    }

    // グローバルなマスターオプションから値を取得
    if (window.globalMasterOptions && window.globalMasterOptions[selectedCategory]) {
      const values = window.globalMasterOptions[selectedCategory];

      if (values && values.length > 0) {
        valueSelect.innerHTML = '<option value="">--選択してください--</option>';
        values.forEach(value => {
          const option = document.createElement('option');
          option.value = value;
          option.textContent = value;
          valueSelect.appendChild(option);
        });
        valueSelect.disabled = false;

        // 値選択時のイベントリスナーを設定（重複回避のため一度削除）
        valueSelect.removeEventListener('change', updateNamePreview);
        valueSelect.addEventListener('change', updateNamePreview);
      }
    }

    updateNamePreview();
  }

  // 基本情報フィールド変更時にハッシュタグプレビューを更新
  function setupHashtagPreviewListeners() {
    const fieldsToWatch = [
      'ブランド(英語)', 'ブランド(カナ)',
      '大分類(カテゴリ)', '中分類(カテゴリ)', '小分類(カテゴリ)',
      '細分類(カテゴリ)', '細分類2', 'アイテム名'
    ];

    fieldsToWatch.forEach(fieldId => {
      const element = document.getElementById(fieldId);
      if (element) {
        element.addEventListener('change', function() {
          updateHashtagCheckboxPreviews();
        });
      }
    });
  }

  // サイズ(表記)フィールドのイベントリスナーを設定
  function setupSizeHyokiListeners() {
    const sizeHyokiTop = document.getElementById('サイズ(表記)_トップス');
    const sizeHyokiBottom = document.getElementById('サイズ(表記)_ボトムス');

    if (sizeHyokiTop) {
      sizeHyokiTop.addEventListener('change', updateDescriptionFromDetail);
    }
    if (sizeHyokiBottom) {
      sizeHyokiBottom.addEventListener('change', updateDescriptionFromDetail);
    }
  }

  // ラグラン判定のイベントリスナーを設定
  function setupRaglanListener() {
    const itemNameField = document.getElementById('アイテム名');
    if (itemNameField) {
      itemNameField.addEventListener('change', updateSizeDisplay);
    }
  }

  /**
   * 商品の説明ブロックの現在の順序を取得
   * @returns {Array} ブロックタイプの配列
   */
  function getDescriptionBlocksOrder() {
    const container = document.getElementById('descriptionBlocksContainer');
    if (!container) return [];

    const blocks = container.querySelectorAll('.desc-draggable-block');
    return Array.from(blocks).map(block => block.dataset.blockType);
  }

  /**
   * 商品の説明ブロックの開閉トグル
   * @param {HTMLElement} button - クリックされた開閉ボタン
   */
  function toggleDescBlock(button) {
    const block = button.closest('.desc-draggable-block');
    if (!block) return;

    const content = block.querySelector('.section-content');
    if (!content) return;

    const isOpen = content.style.display !== 'none';

    if (isOpen) {
      content.style.display = 'none';
      button.textContent = '▶';
    } else {
      content.style.display = 'block';
      button.textContent = '▼';
    }

    // 開閉状態の保存は「保存」ボタン押下時に行う
  }

  /**
   * 商品名ブロックの開閉トグル
   * @param {HTMLElement} button - クリックされた開閉ボタン
   */
  function toggleTitleBlock(button) {
    const block = button.closest('.title-draggable-block');
    if (!block) return;

    const content = block.querySelector('.section-content');
    if (!content) return;

    const isOpen = content.style.display !== 'none';

    if (isOpen) {
      content.style.display = 'none';
      button.textContent = '▶';
    } else {
      content.style.display = 'block';
      button.textContent = '▼';
    }

    // 開閉状態の保存は「保存」ボタン押下時に行う
  }

  /**
   * 商品の説明ブロックのドラッグ&ドロップを初期化
   */
  function initDescriptionBlocksDragDrop() {
    const container = document.getElementById('descriptionBlocksContainer');
    if (!container) return;

    // Sortable.jsを使用してドラッグ&ドロップを初期化
    Sortable.create(container, {
      animation: 150,
      handle: '.drag-handle',
      ghostClass: 'sortable-ghost',
      chosenClass: 'sortable-chosen',
      dragClass: 'sortable-drag',
      onEnd: function() {
        // ドロップ後に並び順を保存
        saveDescriptionBlocksOrder();
      }
    });

    console.log('商品の説明ブロックのドラッグ&ドロップを初期化しました');
  }

  /**
   * 商品の説明ブロックの並び順を保存
   */
  function saveDescriptionBlocksOrder() {
    const container = document.getElementById('descriptionBlocksContainer');
    if (!container) return;

    const blocks = container.querySelectorAll('.desc-draggable-block');
    const order = Array.from(blocks).map(block => block.dataset.blockType);

    console.log('商品の説明ブロック並び順を保存:', order);

    // 設定マスタに保存（TODO: config_loader.jsに保存機能を追加）
    // 今は一旦localStorageに保存
    localStorage.setItem('descriptionBlocksOrder', JSON.stringify(order));
  }

  /**
   * 商品の説明ブロックの並び順を読み込み
   */
  function loadDescriptionBlocksOrder() {
    const savedOrder = localStorage.getItem('descriptionBlocksOrder');
    if (!savedOrder) return;

    try {
      const order = JSON.parse(savedOrder);
      const container = document.getElementById('descriptionBlocksContainer');
      if (!container) return;

      // 並び順に応じてブロックを並び替え
      order.forEach(blockType => {
        const block = container.querySelector(`[data-block-type="${blockType}"]`);
        if (block) {
          container.appendChild(block);
        }
      });

      console.log('商品の説明ブロック並び順を復元しました:', order);
    } catch (error) {
      console.error('商品の説明ブロック並び順の読み込みエラー:', error);
    }
  }

  /**
   * 商品の説明ブロックの開閉状態を保存
   */
  function saveDescriptionBlocksCollapseState() {
    const container = document.getElementById('descriptionBlocksContainer');
    if (!container) return;

    const blocks = container.querySelectorAll('.desc-draggable-block');
    const state = {};

    blocks.forEach(block => {
      const content = block.querySelector('.section-content');
      if (content) {
        const blockType = block.dataset.blockType;
        state[blockType] = content.style.display !== 'none';
      }
    });

    console.log('商品の説明ブロック開閉状態を保存:', state);

    // 今は一旦localStorageに保存
    localStorage.setItem('descriptionBlocksCollapseState', JSON.stringify(state));
  }

  /**
   * 商品名ブロックの開閉状態を保存
   */
  function saveTitleBlocksCollapseState() {
    const container = document.getElementById('titleBlockContainer');
    if (!container) return;

    const blocks = container.querySelectorAll('.title-draggable-block');
    const state = {};

    blocks.forEach(block => {
      const content = block.querySelector('.section-content');
      if (content) {
        const blockId = block.dataset.blockId;
        state[blockId] = content.style.display !== 'none';
      }
    });

    console.log('商品名ブロック開閉状態を保存:', state);

    // localStorageに保存
    localStorage.setItem('titleBlocksCollapseState', JSON.stringify(state));
  }

  /**
   * 商品の説明ブロックの開閉状態を読み込み
   */
  function loadDescriptionBlocksCollapseState() {
    const container = document.getElementById('descriptionBlocksContainer');
    if (!container) return;

    const savedState = localStorage.getItem('descriptionBlocksCollapseState');

    // デフォルトで閉じるブロック
    const defaultClosedBlocks = ['discount', 'hashtag'];

    let state = {};

    if (savedState) {
      try {
        state = JSON.parse(savedState);
        console.log('商品の説明ブロック開閉状態を復元しました:', state);
      } catch (error) {
        console.error('商品の説明ブロック開閉状態の読み込みエラー:', error);
        // エラー時はデフォルト状態を使用
        defaultClosedBlocks.forEach(blockType => {
          state[blockType] = false;
        });
      }
    } else {
      // 初回読み込み時はデフォルトで閉じる
      defaultClosedBlocks.forEach(blockType => {
        state[blockType] = false;
      });
      console.log('デフォルト開閉状態を適用しました:', state);
    }

    // すべてのブロックに開閉状態を適用
    const blocks = container.querySelectorAll('.desc-draggable-block');
    blocks.forEach(block => {
      const blockType = block.dataset.blockType;
      const content = block.querySelector('.section-content');
      const button = block.querySelector('.collapse-btn');

      if (!content || !button) return;

      // stateに含まれている場合はその状態を使用、含まれていない場合は開いた状態
      const isOpen = state[blockType] !== undefined ? state[blockType] : true;

      if (isOpen) {
        content.style.display = 'block';
        button.textContent = '▼';
      } else {
        content.style.display = 'none';
        button.textContent = '▶';
      }
    });
  }

  /**
   * 商品名ブロックの開閉状態を読み込み
   */
  function loadTitleBlocksCollapseState() {
    const container = document.getElementById('titleBlockContainer');
    if (!container) return;

    const savedState = localStorage.getItem('titleBlocksCollapseState');

    let state = {};

    if (savedState) {
      try {
        state = JSON.parse(savedState);
        console.log('商品名ブロック開閉状態を復元しました:', state);
      } catch (error) {
        console.error('商品名ブロック開閉状態の読み込みエラー:', error);
      }
    }

    // すべてのブロックに開閉状態を適用
    const blocks = container.querySelectorAll('.title-draggable-block');
    blocks.forEach(block => {
      const blockId = block.dataset.blockId;
      const content = block.querySelector('.section-content');
      const button = block.querySelector('.collapse-btn');

      if (!content || !button) return;

      // stateに含まれている場合はその状態を使用、含まれていない場合は開いた状態（デフォルト）
      const isOpen = state[blockId] !== undefined ? state[blockId] : true;

      if (isOpen) {
        content.style.display = 'block';
        button.textContent = '▼';
      } else {
        content.style.display = 'none';
        button.textContent = '▶';
      }
    });
  }

  // ページ読み込み時にイベントリスナーを設定
  setTimeout(() => {
    setupHashtagPreviewListeners();
    setupSizeHyokiListeners();
    setupRaglanListener();
    initTitleBlockDragDrop();
    applyTitleBlockOrder();
    restoreManagementNumberPlacementSettings();
    initDescriptionBlocksDragDrop();
    loadDescriptionBlocksOrder();
    loadDescriptionBlocksCollapseState();
    loadTitleBlocksCollapseState();
  }, 1000);

</script>

<!-- Firebase Cloud Messaging - フォアグラウンド通知対応 -->
<script type="module">
  // Firebase設定
  const firebaseConfig = {
    apiKey: "AIzaSyAwJKTz1gm3CIz_R4YTlbQopgaBq1ULt1A",
    authDomain: "reborn-pwa.firebaseapp.com",
    projectId: "reborn-pwa",
    storageBucket: "reborn-pwa.firebasestorage.app",
    messagingSenderId: "345653439471",
    appId: "1:345653439471:web:7620819ce3f022d9cd241a",
    measurementId: "G-SX48K45X75"
  };

  // Firebase初期化
  async function initFirebaseMessaging() {
    try {
      // Firebase App と Messaging をインポート
      const { initializeApp, getApps, getApp } = await import('https://www.gstatic.com/firebasejs/10.7.1/firebase-app.js');
      const { getMessaging, onMessage } = await import('https://www.gstatic.com/firebasejs/10.7.1/firebase-messaging.js');

      // 既に初期化されているかチェック
      let app;
      if (getApps().length === 0) {
        app = initializeApp(firebaseConfig);
        console.log('✅ Firebase App初期化（商品登録ページ）');
      } else {
        app = getApp();
        console.log('✅ 既存のFirebase Appを使用（商品登録ページ）');
      }

      const messaging = getMessaging(app);
      console.log('✅ Firebase Messaging取得完了（商品登録ページ）');

      // フォアグラウンドメッセージ受信（アプリが開いている時）
      onMessage(messaging, (payload) => {
        console.log('📨 フォアグラウンドメッセージ受信（商品登録ページ）:', payload);

        // 通知データを取得
        const notificationTitle = payload.data?.title || payload.notification?.title || 'REBORN';
        const notificationBody = payload.data?.body || payload.notification?.body || '新しい通知があります';

        // バッジを更新
        incrementBadgeIfAvailable();

        // ブラウザ通知を表示
        if (Notification.permission === 'granted') {
          new Notification(notificationTitle, {
            body: notificationBody,
            icon: '/reborn-inventory-system/icon-180.png',
            badge: '/reborn-inventory-system/icon-192.png',
            tag: 'reborn-notification-product-page',
            requireInteraction: false  // 自動で消える
          });
          console.log('🔔 ブラウザ通知を表示しました（商品登録ページ）');
        }
      });

    } catch (error) {
      // エラーが発生してもページの他の機能に影響しないようにする
      console.error('❌ Firebase Messaging初期化エラー:', error);
      console.log('⚠️ 通知機能は利用できませんが、他の機能は正常に動作します');
    }
  }

  // バッジカウントを増やす（利用可能な場合）
  function incrementBadgeIfAvailable() {
    try {
      // localStorageから現在のカウントを取得
      const currentCount = parseInt(localStorage.getItem('badgeCount') || '0', 10);
      const newCount = currentCount + 1;

      // localStorageに保存
      localStorage.setItem('badgeCount', newCount.toString());
      console.log('📛 バッジカウント更新:', newCount);

      // Badge APIで更新（対応ブラウザのみ）
      if ('setAppBadge' in navigator) {
        navigator.setAppBadge(newCount)
          .then(() => console.log('✅ Badge API更新成功:', newCount))
          .catch(err => console.error('❌ Badge APIエラー:', err));
      }
    } catch (error) {
      console.error('❌ バッジ更新エラー:', error);
    }
  }

  // ページ読み込み完了後、少し遅延させてからFirebase Messagingを初期化
  // （他のスクリプトが完全に読み込まれるのを待つ）
  if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', () => {
      setTimeout(initFirebaseMessaging, 2000);
    });
  } else {
    setTimeout(initFirebaseMessaging, 2000);
  }
</script>